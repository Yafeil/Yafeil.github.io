<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[requirements文件。mkpython的字符串处理函数mk]]></title>
    <url>%2F2018%2F10%2F14%2Frequirements%E6%96%87%E4%BB%B6%E3%80%82mkpython%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0mk%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[requirements文件]]></title>
    <url>%2F2018%2F10%2F14%2Frequirements%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[python项目中必须包含一个requirements.txt文件，用于记录所有依赖包及其精确的版本号，以便在新的环境中进行部署操作。 在虚拟环境中使用以下命令将当前虚拟环境中的依赖包以版本号生成至文件中。 1$ pip freeze &gt; requirements.txt 需求内容文件如下： 12345alembic==0.9.2blinker==1.4click==6.7dominate==2.3.1Flask==0.10.1 当需要创建这个虚拟环境的完全副本，可以创建一个新的虚拟环境，并在其上运行以下命令： 1$ pip install -r requirements.txt]]></content>
      <categories>
        <category>Flask</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[python的字符串处理函数]]></title>
    <url>%2F2018%2F10%2F11%2Fpython%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[string.capitalize()用法： 把字符串的第一个字母大写 12345a = 'abc'b = a.capitalize()print(b)*******************************************Abc count() 方法用法： Python count() 方法用于统计字符串里某个字符出现的次数。可选参数为在字符串搜索的开始与结束位置。 12345678910111213# str.count(sub, start= 0,end=len(string))# sub -- 搜索的子字符串# start -- 字符串开始搜索的位置。默认为第一个字符,第一个字符索引值为0。# end -- 字符串中结束搜索的位置。字符中第一个字符的索引为 0。默认为字符串的最后一个位置。#!/usr/bin/python str = "this is string example....wow!!!"; sub = "i";print "str.count(sub, 4, 40) : ", str.count(sub, 4, 40)sub = "wow";print "str.count(sub) : ", str.count(sub) find方法用法： Python find() 方法检测字符串中是否包含子字符串 str ，如果指定 beg（开始） 和 end（结束） 范围，则检查是否包含在指定范围内，如果包含子字符串返回开始的索引值，否则返回-1。 12345678910111213141516# str.find(str, beg=0, end=len(string))# str -- 指定检索的字符串# beg -- 开始索引，默认为0。# end -- 结束索引，默认为字符串的长度。#!/usr/bin/python str1 = "this is string example....wow!!!";str2 = "exam"; print str1.find(str2);print str1.find(str2, 10);print str1.find(str2, 40);************************************************1515-1]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css基础]]></title>
    <url>%2F2018%2F10%2F03%2Fcss%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[css的简介什么是css层叠样式表，css是对html进行样式修饰的语言 层叠：就是层层的覆盖叠加，如果不同的css样式对同一html进行修饰，样式有冲突的部分应用优先级高的，不冲突的部分共同作用样式表，就是css属性样式的集合 样式表：就是css属性样式的集合 css作用 修饰html，使其html样式更加好看 提高样式代码的复用性 html的内容与样式相分离，便于后期维护 css的引入方式和书写规范 内嵌样式 内嵌样式是把css的代码嵌入到html标签中 语法： 使用style属性将样式嵌入到html标签中 属性的写法：属性：属性值 多个属性之间使用分号隔开 1&lt;div style="color:red;font-size:5px;"&gt;你好啊，小朋友&lt;/div&gt; 内部样式 在head标签中使用style标签进行css的引入 语法： 使用style标签进行css的引入 属性：type：告知浏览器使用css解析器去解析 属性的写法：属性：属性值 多个属性之间使用分号隔开 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Insert title here&lt;/title&gt; &lt;style type="text/css"&gt; div&#123;color:red;font-size:100px;&#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;!--&lt;div style="color:red;font-size:5px;"&gt;你好啊，小朋友&lt;/div&gt;&gt;--&gt; &lt;div&gt;Hello,little friend&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 外部样式 将css样式抽取成一个单独的css文件，谁去使用给谁 语法： 创建css 文件，将css属性写在css文件中 在head中使用link标签进行引入 rel代表要引入文件与html的关系 type：告知浏览器使用css解析器去解析 href：css文件地址 属性的写法：属性：属性值 多个属性之间使用分号隔开 demo1.html 123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Insert title here&lt;/title&gt; &lt;link rel="stylesheet" type="text/css" href="demo1.css"/&gt; &lt;/head&gt; &lt;body&gt; &lt;!--&lt;div style="color:red;font-size:5px;"&gt;你好啊，小朋友&lt;/div&gt;&gt;--&gt; &lt;div&gt;Hello,little friend&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; demo1.css 1div&#123;color: red; font-size: 100px;&#125; @import方式123&lt;style type="text/css"&gt; @import url("css地址");&lt;/style&gt; link与@import区别 link所有的浏览器都支持，import部分低版本的IE不支持 import方式是等待html加载之后再加载 import方式不支持js的动态修改 css选择器基本选择器 元素选择器 语法：html标签名{css属性} 123&lt;style type="text/css"&gt; span&#123;color:red;font-size:100px&#125;&lt;/style&gt; 成都v 属性选择器伪元素选择器层级选择器css属性css盒子模型]]></content>
      <categories>
        <category>CSS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[html基础]]></title>
    <url>%2F2018%2F09%2F30%2Fhtml%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[HTML基本标签文件标签 html :根标签 head body 123456789101112&lt;!--html为根标签--&gt;&lt;html&gt; &lt;head&gt; &lt;!--title 页面标题--&gt; &lt;title&gt;我的第一个offer&lt;/title&gt; &lt;/head&gt; &lt;!--body 我们需要展示的信息--&gt; &lt;body text="green" bgcolor="blue" size="5"&gt; &lt;/body&gt;&lt;/html&gt;注： 排版标签 注释标签 换行标签 段落标签 属性 ：align:对齐方式 left canter right 水平线标签 属性：width:长度 50% size：粗细 10px color:颜色 align：对齐方式 块标签 div 行级块标签 span 行内块标签 文字标签 基本文字标签 : color 颜色 size 大小 最大值：7 最小值：1 默认值：3 face 字体类型 黑体、宋体… 标题标签 h1到h6 依次减小 默认字体加粗 默认占据一行 清单标签 无序列表 属性：type：disc square circle 1234567&lt;html&gt; &lt;body &gt; &lt;ul type="circle"&gt; &lt;li&gt;Love&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt;&lt;/html&gt; :列表项 有序列表： type: 1, A,I, a,i 列表项 图形标签 src:图形的地址 width：宽度 heigh：高度 border：边框 align：对齐方式 代表图片与相邻的文本的相对位置 top midde bottom alt ：图片的文字说明 1&lt;img src="images/1.jpg" width="50%" height="70%" border="5" align="center" alt="足球宝贝"/&gt; 链接标签 &lt;a&gt; href 跳转的页面地址 name 名称 target：_selt _blank 表格标签]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vim的使用]]></title>
    <url>%2F2018%2F09%2F26%2Fvim%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Vim中常用命令 命令 作用 dd 删除(剪切)光标所在行 5dd 删除(剪切)从光标处开始的5行 yy (yank 挂起) 复制光标所在整行 5yy 复制从光标处开始的5行 u 撤销上一步操作 p 将之前删除或者复制过来的数据黏贴到光标后面 命令 作用 :w 保存 :q 退出 :q! 强制退出 :wq! 强制保存退出 :set nu 显示行号 :set nonu 不显示行号 : 命令 执行该命令 : 整数 跳转到该行 :s/one/two 将当前光标所在行的第一个one替换成two :s/one/two/g 将当前光标所在行的所有one替换成two :%s/one/two/g 将全文中的所有one替换成two ?字符串 在文本中从下自上搜索该字符串的串 /字符串 在文本中从上自下搜索该字符串的串]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[模块的导入]]></title>
    <url>%2F2018%2F09%2F24%2F%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AF%BC%E5%85%A5%2F</url>
    <content type="text"><![CDATA[在python中，每个py文件被称为模块，每个具有__init__.py文件的目录被称为包。只要模块或者包所在的目录在sys.path,就可以使用import模块或者import包来使用 import导入为绝对导入 import只能带入模块，不能导入模块中的对象(类、函数、变量等)]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[linux基本命令]]></title>
    <url>%2F2018%2F09%2F23%2Flinux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[pwd命令该命令用于显示用户当前用户所处的工作目录 1$ pwd cd命令该命令用于切换工作路径，格式为”cd [工作目录]” cat命令cat命令用于查看纯文本文件(内容较少的)，格式为cat [选项] [文件] 如果在查看文本内容时还想顺便显示行号的话，不妨在cat命令后面追加一个 -n 参数 moremore命令用于查看纯文本文件(内容较多的)，格式为more [选项] 文件名 headhead命令用于查看纯文本文档的前N行，格式为head [选项] [文件] 在阅读文档时，如果只想查看文本中前20行的内容，head可以排上用场 1$ head -n 20 test.txt tall命令tail命令用于查看纯文本文档的后N行或持续刷新内容，格式为tail [选项] [文件] 1234# 查看文本内容的最后20行$ tail -n 20# 查看最新日志文件$ tail -f 文件名 grep查找文件内容，很多时候，并不需要列出文件的全部内容，用户要做的只要找到包含某些信息的一行。这个时候，如果使用more命令一行一行去找的话，无疑是耗时耗力的。当为了在文件中寻找某些信息时，可以使用grep命令。 该命令是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来。 命令格式：grep [选项] “模式” [文件] find随着文件的増多，使用搜索工具成了顺理成章的事情。find就是这样的一个命令，它能够迅速在指定的范围内查找到文件。 1find [-path] -options [expression] 例如，希望在/usr/bin/目录下查找zip命令： 1find /usr/bin/ -name zip -print toptop命令用于动态地监视进程活动与系统负载等信息 第一行：系统时间、运行时间、登录终端数、系统负载 第二行：进程总数、运行中的进程数、睡眠中的进程数、停止的进程数、僵尸的进程数 第三行：用户占用资源百分比、系统内核占用资源百分比、改变优先级的进程资源百分比、空闲的资源百分比等 第四行：物理内存总量、内存使用量、内存空闲量、作为内核缓存的内存量。 第五行：虚拟内存总量、虚拟内存使用量、虚拟内存空闲量、已被提前加载的内存量 killkill命令用于终止某个指定PID的服务进程，格式为kill [参数] [进程PID]]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[手表调整日期方法]]></title>
    <url>%2F2018%2F09%2F21%2F%E6%89%8B%E8%A1%A8%E8%B0%83%E6%95%B4%E6%97%A5%E6%9C%9F%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[经过多方摸索，终于得到一套手表调日期正确方法，这个方法比较科学，避免了对手表日期模组的损坏，是业内通行的较标准的手表调日期正确方法，保证不会颠倒黑白。其实道理也比较简单明了：一天有24小时，但是腕表的表盘一圈只表示十二个小时，所以但凡是有日期或者星期功能的腕表，必然存在区分上下午的问题，这样的腕表，时针围着表盘转两圈，也就是两个12小时，日期和星期才会跳一次。只要掌握了这个原理，调整起来就很简单了。 手表调日期正确方法步骤一，把表冠拔出，让腕表所有指针停走，进入“调整时间”状态。此时把时间调整至六点整。这样做是为了避免一会儿调日期星期时损坏日期模组。 手表调日期正确方法步骤二，把表冠往回推一扣，到“调整日期和星期”的状态。此时腕表指针开始正常转动，不用理会。 手表调日期正确方法步骤三，调整日期以及星期至你调表的日期的前一天。例如今天星期五，29号，你现在调表，那就把星期调到星期四，日期调到28号。 手表调日期正确方法步骤四，关键步骤。再次把表冠拔出至指针停走的“调整时间”状态，开始调整时间，让指针顺时针转动(切不可令指针逆时针转动，对时间模组有很大损伤)，这时动作需要柔和，调整时间直到指针指示接近12点左右时，发现日期和星期跳转到下一天(也就是调表的这天)，这个跳转也许会在时针第二次经过12点时才会发生，没关系。日期跳转说明表的指针现在开始指示你调表当天的上午这个时段，如果你恰好是在上午调表，那么把表调整为目前的精确时间，然后把表冠完全推回，腕表指针正常转动，调表结束。如果你是在下午调表，那么继续调整时间，让时针再次通过12点，(此时日期和星期不会跳转，依然显示调表当天)这时腕表所指示的将是你调表当天的下午时段，这时你继续把腕表时间调整至当前的精确时间，把表冠完全推回，腕表指针正常转动，调表结束。]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Watch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java集合]]></title>
    <url>%2F2018%2F09%2F20%2Fjava%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[Java集合可以分为Collection和Map两种体系 Collection接口 Set接口：元素是无序的 List接口：元素是有序的，可重复的集合 Map接口：具有映射关系“key-value”的集合]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[static关键字]]></title>
    <url>%2F2018%2F09%2F20%2Fstatic%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[通称来说，当创建类的时候，就是在描述那个类的对象的外观与行为，除非用new创建那个类的对象，否则，实际上并未获得任何对象。执行new来创建对象时，数据存储空间才会被分配，其方法才可以供外界调用。 有两种情况用上述方法时无法解决的。 只想为某特定域分配单一存储空间，而不去考虑创建多少个对象，甚至根本就不创建任何对象 希望某个方法不与包含它的类的任何对象关联在一起。也就是说，即使没有创建对象，也能够调用这个方法。 通过static关键字可以满足这两方面的需要。当声明一个事物时static时，就意味着这个域或者方法不会域包含它的那个类的任何对象实例]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[进程调度]]></title>
    <url>%2F2018%2F09%2F18%2F%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[在多道程序系统中，一个作业被提交后必须经过处理机调度后，方能获得处理及执行。 处理机调度层次低级调度通常也把低级调度称为进程调度或者短程调度，它所调度的对象是进程。 进程调度方式进程调度可采用以下两种方式 非抢占式 采用这种调度方式时，一旦把处理机分配给某进程后，不管它要运行多长时间，都一直让它运行下去，绝不会因为时钟中断等原因而抢占正在运行进程的处理机，也不允许其它进程抢占已经分配给它的处理机，直至该进程完成，自愿释放处理机，或发生某事件而被阻塞时，才能把处理机分配给其它进程。 在采用非抢占调度方式时，可能引起进程调度的因素可归结为如下几个： 正在执行的进程执行完毕，或因发生某事件而不能再继续执行； 执行中的进程因提出 I/O 请求而暂停执行； 在进程通信或同步过程中执行了某种原语操作，如 P 操作(wait 操作)、Block 原语、 Wakeup 原语等 这种调度方式的优点是实现简单，系统开销小，适用于大多数的批处理系统环境。但 它难以满足紧急任务的要求——立即执行，因而可能造成难以预料的后果。显然，在要求 比较严格的实时系统中，不宜采用这种调度方式。 抢占式 这种调度方式允许调度程序根据某种原则去暂停某个正在执行的进程，将已经分配给该进程的处理机重新分配给另一个进程。抢占方式的优点是，可以防止一个长进程长时间占用处理机，能为大多数进程提供更公平的服务，，特别是能满足对响应时间有着较严格要求的 实时任务的需求。但抢占方式比非抢占方式调度所需付出的开销较大。抢占调度方式是基 于一定原则的，主要有如下几条： 优先权原则。通常是对一些重要的和紧急的作业赋予较高的优先权。当这种作业到 达时，如果其优先权比正在执行进程的优先权高，便停止正在执行(当前)的进程，将处理机 分配给优先权高的新到的进程，使之执行；或者说，允许优先权高的新到进程抢占当前进 程的处理机。 短作业(进程)优先原则。当新到达的作业(进程)比正在执行的作业(进程)明显的短 时，将暂停当前长作业(进程)的执行，将处理机分配给新到的短作业(进程)，使之优先执行；或者说，短作业(进程)可以抢占当前较长作业(进程)的处理机。 时间片原则。各进程按时间片轮流运行，当一个时间片用完后，便停止该进程的执 行而重新进行调度。这种原则适用于分时系统、大多数的实时系统，以及要求较高的批处 理系统。 中级调度中级调度(Intermediate Level Scheduling)又称中程调度(Medium-Term Scheduling)。引入中级调度的主要目的是为了提高内存利用率和系统吞吐量。为此，应使那些暂时不能运行的进程不在占用宝贵的内存资源，而将它们调至外存上去等待，把此时的进程状态称为就绪驻外存状态或挂起状态。当这些进程又重新具备运行条件且内存又稍有空闲时，由中级调度来决定把外存上的那些具备条件的就绪进程重新调入内存，并修改其状态为就绪状态，挂在就绪队列上等待进程调度。 调度算法先来先服务和短作业（进程）优先调度算法先来先服务调度算法先来先服务(FCFS)调度算法是一种最简单的调度算法，该算法既可以用于作业调度，也可用于进程调度。当在作业调度中采用该算法时，每次调度都是从后备作业队列中选择一个或者多个最先进入该队列的作业，将他们调入内存，为他们分配资源，创建进程，然后放入就绪队列。在进程调度中采用FCFS算法时，则每次调度是从就绪队列中选择一个最先进入该队列的进程，为之分配处理机，使之投入运行。该进程一直运行到完成或发生某事件而阻塞后才放弃处理机。 FCFS算法比较有利于长作业（进程），而不利于短作业（进程）。 短作业（进程）优先调度算法短作业（进程）优先调度算法，是对短作业或短进程优先调度的算法。它们可以分别用于作业调度和进程调度。短作业优先的调度算法是从后备队列中选择一个或者若干个估计运行时间最短的作业，将他们调入内存运行。而短进程优先调度算法则是从就绪队列中选出一个估计时间最短的进程，将处理机分配给它，使它立即执行并一直执行到完成，或发生某事件而被阻塞放弃处理机时在重新调入。 高优先权优先算法基于时间片的轮转调度算法时间片轮转法 原理 在早期的时间片轮转法中，系统将所有的就绪进程按先来先服务的原则排成一个队列，每次调度时，把CPU分配给首进程，并令其执行一个时间片。时间片的大小从几ms到几百ms。当执行的时间片用完时，由一个计时器发出时钟中断请求，调度程序便据此信号来停止该进程的执行，并将它送往就绪队列的末尾；然后，再把处理机分配给就绪队列中的首进程，同时也让他完成一个时间片。这样就可以保证就绪队列中的所有进程在一给定的时间内均能获得一时间片的处理机执行时间。换言之，系统能在给定的时间内响应所有用户的请求。 时间片大小的确定 一个较为可取的大小是，时间片略大于一次典型的交互所需要的时间。这样可使大多数进程在一个时间片内完成。 多级反馈队列调度算法前面介绍的各种用作进程调度的算法都有一定的局限性。如短进程优先的调度算法，仅照顾了短进程而忽略了长进程，而且如果并未指明进程的长度，则短进程优先和基于进程长度的抢占式调度算法都将无法使用。而多级反馈队列调度算法则不必事先知道各种进程所需的执行时间，而且还可以满足各种类型进程的需要，因而它是目前被公认的一种较好的进程调度算法。在采用多级反馈队列调度算法的系统中，调度算法的实施过程如下所述。 应设置多个就绪队列，并为各个队列赋予不同的优先级。第一个队列的优先级最高，第二个队列次之，其余各队列的优先权逐个降低。该算法赋予各个队列中进程执行时间片的大小也各不相同，在优先权愈高的队列中，为每个进程所规定的执行时间片就愈小。例如，第二个队列的时间片要比第一个队列的时间片长一倍，……，第 i+1 个队列的时间片要比第 i 个队列的时间片长一倍。如图是多级反馈队列算法的示意 . 当一个新进程进入内存后，首先将它放入第一队列的末尾，按 FCFS 原则排队等待调度。当轮到该进程执行时，如它能在该时间片内完成，便可准备撤离系统；如果它在一个时间片结束时尚未完成，调度程序便将该进程转入第二队列的末尾，再同样地按 FCFS原则等待调度执行；如果它在第二队列中运行一个时间片后仍未完成，再依次将它放入第三队列，……，如此下去，当一个长作业(进程)从第一队列依次降到第 n 队列后，在第 n 队 列中便采取按时间片轮转的方式运行 。 仅当第一队列空闲时，调度程序才调度第二队列中的进程运行；仅当第 1～(i-1)队列均空时，才会调度第 i 队列中的进程运行。如果处理机正在第 i 队列中为某进程服务时，又有新进程进入优先权较高的队列(第 1～(i-1)中的任何一个队列)，则此时新进程将抢占正在运行进程的处理机，即由调度程序把正在运行的进程放回到第 i 队列的末尾，把处理机分配给新到的高优先权进程 。 多级反馈队列调度算法的性能 s多级反馈队列调度算法具有较好的性能，能很好地满足各种类型用户的需要 终端型作业用户。由于终端型作业用户所提交的作业大多属于交互型作业，作业通常较小，系统只要能使这些作业(进程)在第一队列所规定的时间片内完成，便可使终端型作业用户都感到满意 短批处理作业用户。对于很短的批处理型作业，开始时像终端型作业一样，如果仅在第一队列中执行一个时间片即可完成，便可获得与终端型作业一样的响应时间。对于稍长的作业，通常也只需在第二队列和第三队列各执行一个时间片即可完成，其周转时间仍然较短 长批处理作业用户。对于长作业，它将依次在第 1，2，…，n 个队列中运行，然后再按轮转方式运行，用户不必担心其作业长期得不到处理]]></content>
      <categories>
        <category>Operating System</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[python的字典]]></title>
    <url>%2F2018%2F09%2F18%2Fpython%E7%9A%84%E5%AD%97%E5%85%B8%2F</url>
    <content type="text"><![CDATA[字典的创建传统的文字表达式1d = &#123;'name': 'Allen', 'age': 21, 'gender': 'male'&#125; 动态分配键值1234d = &#123;&#125;d['name'] = 'Allen'd['age'] = 21d['gender'] = 'male' 字典键值表1d = dict(name='Allen', age=14, gender='male') 这种形式所需的代码量较少，但是键必须都是字符串才可以 字典键值元祖表123e = dict([('name','Allen'),('age',21),('gender','male')])&gt;&gt; e&#123;'age': 21, 'name': 'Allen', 'gender': 'male'&#125; 所有键的值字典的遍历键的遍历123456a = &#123;'a': 1, 'b': 2&#125;for key in a.keys(): print(key, a[key])-----------------------------------------------------------------------------------a 1b 2 值的遍历123456a = &#123;'a':1,'b':2&#125;for val in a.values(): print(val)---------------------------------------------------------------------------------------------------12 键值遍历12345a = &#123;'a': 1, 'b': 2&#125;for key, value in a.items(): print(key, value, end=' ')-----------------------------------------------------------------------------------a 1 b 2 123456a = &#123;'a': 1, 'b': 2&#125;for kv in a.items(): print(kv)--------------------------------------------------------------------------------------------------('a', 1)('b', 2) 字典的排序按key值排序12345d = &#123;'lilee': 25, 'wangyan': 21, 'liqun': 32, 'lidaming': 19&#125;a = sorted(d.keys())print(a)---------------------------------------------------------------------------------------------------['lidaming', 'lilee', 'liqun', 'wangyan'] 直接使用sorted(d.keys())就能按key值对字典排序，这里是按照顺序对key值排序的，如果想按照倒序排序的话，则只要将reverse置为true即可。 按value值排序12345d = &#123;'lilee': 25, 'wangyan': 21, 'liqun': 32, 'lidaming': 19&#125;a = sorted(d.items(), key=lambda item: item[1])print(a)---------------------------------------------------------------------------------------------------[('lidaming', 19), ('wangyan', 21), ('lilee', 25), ('liqun', 32)] 这里的d.items()实际上是将d转换为可迭代对象，迭代对象的元素为（‘lilee’,25）、（‘wangyan’,21）、（‘liqun’,32）、（‘lidaming’,19），items()方法将字典的元素转化为了元组，而这里key参数对应的lambda表达式的意思则是选取元组中的第二个元素作为比较参数（如果写作key=lambda item:item[0]的话则是选取第一个元素作为比较对象，也就是key值作为比较对象。lambda x:y中x表示输出参数，y表示lambda函数的返回值），所以采用这种方法可以对字典的value进行排序。注意排序后的返回值是一个list，而原字典中的名值对被转换为了list中的元组。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>set</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库的三个删除命令]]></title>
    <url>%2F2018%2F09%2F18%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%89%E4%B8%AA%E5%88%A0%E9%99%A4%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[简单说一说drop,delete,truncate的区别SQL中的drop，delete，truncate都表示删除，但是三者有一些差异 delete和truncate只删除表的数据不删除表的结构 速度一般来说，drop&gt;truncate&gt;delete delete语句是DML(Data Maintain Language)，这个操作会放到rollback segement中，事务提交后才生效；如果有相应的trigger，执行的时候将被触发。truncate和drop为DDL(data define language),操作立即生效，元数据不放到rollback segment中，不能回滚，操作不触发trigger drop,delete和truncate分别在什么场景下使用 不需要一张表的时候，用drop 想要删除部分数据行的时候，用delete，并且带上where子句 保留表而删除所有数据时用truncate DROP删除数据库是将已经存在的数据库从磁盘空间上清除，清除之后，数据库中所有的数据也将一同被删除。 1DROP DATABASE database_name;]]></content>
      <categories>
        <category>Database</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JVM堆内存设置]]></title>
    <url>%2F2018%2F09%2F17%2FJVM%E5%A0%86%E5%86%85%E5%AD%98%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[堆内存的设置原理JVM堆内存分为2块： Permanent Space和Heap Space Permanent即持久代(Permanent Generation)，主要存放的是Java类定义信息，与垃圾收集器要收集的Java对象关系不大 Heap = {Old + New = {Eden，from，to}}，old即年老代，New即年轻代(Young Generation)。年老代和年轻代的划分对垃圾收集影响比较大。 年轻代所有新生成的对象首先都是放在年轻代。年轻代的目标就是尽可能快速的收集掉那些生命周期较短的对象。年轻代一般分3个区，1个Eden区，2个Survivor区(from和to)。 大部分对象在Eden区中生成。当Eden区满时，还存活的对象将被复制到Survivor区（两个中的一个），当一个Survivor区满时，此区的存活对象将被复制到另外一个Survivor区，当另一个Survivor区也满了的时候，从前一个Survivor区复制过来的并且此时哈存活的对象，将有可能被复制到年老代。 2个Survivor区是对称的，没有先后关系，所以同一个Survivor区中可能同时存在从Eden区复制过来的对象，和从另一个Survivor区复制过来的对象；而复制到年老区的只有从另一个Survivor区过来的对象。而且，因为需要交换的原因，Survivor区至少有一个是空的。特殊的情况下，根据程序需要，Survivor区是可以配置为多个的（多于2个），这样可以增加对象在年轻代中的存在时间，减少被放到年老代的可能。 针对年轻代的垃圾回收即 Young GC 年老代在年轻代中经历了N次（可配置）垃圾回收后仍然存活的对象，就会被复制到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。 针对年老代的垃圾回收即 Full GC。 持久代用于存放静态类型数据，如 Java Class, Method 等。持久代对垃圾回收没有显著影响。但是有些应用可能动态生成或调用一些Class，例如 Hibernate CGLib 等，在这种时候往往需要设置一个比较大的持久代空间来存放这些运行过程中动态增加的类型。 所以，当一组对象生成时，内存申请过程如下： JVM会试图为相关Java对象在年轻代的Eden区中初始化一块内存区域。 当Eden区空间足够时，内存申请结束。否则执行下一步。 JVM试图释放在Eden区中所有不活跃的对象（Young GC）。释放后若Eden空间仍然不足以放入新对象，JVM则试图将部分Eden区中活跃对象放入Survivor区。 Survivor区被用来作为Eden区及年老代的中间交换区域。当年老代空间足够时，Survivor区中存活了一定次数的对象会被移到年老代。 当年老代空间不够时，JVM会在年老代进行完全的垃圾回收（Full GC）。 Full GC后，若Survivor区及年老代仍然无法存放从Eden区复制过来的对象，则会导致JVM无法在Eden区为新生成的对象申请内存，即出现“Out of Memory”。 OOM（“Out of Memory”）异常一般主要有如下2种原因： \1. 年老代溢出，表现为：java.lang.OutOfMemoryError:Javaheapspace 这是最常见的情况，产生的原因可能是：设置的内存参数Xmx过小或程序的内存泄露及使用不当问题。 例如循环上万次的字符串处理、创建上千万个对象、在一段代码内申请上百M甚至上G的内存。还有的时候虽然不会报内存溢出，却会使系统不间断的垃圾回收，也无法处理其它请求。这种情况下除了检查程序、打印堆内存等方法排查，还可以借助一些内存分析工具，比如MAT就很不错。 \2. 持久代溢出，表现为：java.lang.OutOfMemoryError:PermGenspace 通常由于持久代设置过小，动态加载了大量Java类而导致溢出，解决办法唯有将参数 -XX:MaxPermSize 调大（一般256m能满足绝大多数应用程序需求）。将部分Java类放到容器共享区（例如Tomcat share lib）去加载的办法也是一个思路，但前提是容器里部署了多个应用，且这些应用有大量的共享类库。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库范式]]></title>
    <url>%2F2018%2F09%2F17%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E8%8C%83%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[数据库表结构设计时，遵从一定的范式(NF,Normal Form)可以减少数据冗余和操作异常。 第一范式(1NF)1NF指的是每个属性值都是不可再分的。 满足1NF的关系被称为规范化的关系，1NF也是关系模式应具备的最起码的条件。 比如有这样一张表user的两列: name phone_number phone_number 这一列只存储一个电话号码，如果一条数据同时存储了住宅电话和手机号码，比如：“010-65576558,13765556765”，那么这个属性是可以再分的，违背了 1NF。 第二范式(2NF)2NF要求去除局部依赖，也就是说，表的属性完全依赖于全部主键，而不是部分主键 比如说user表包含下面几列： user_id name phone_number job_id job_description 其中job_description依赖于job_id，而不是全部主键(user_id job_id)所以违背了2NF。这时可以把job部分单独抽取成一张job表，去除冗余。 第三范式 (3NF)3NF要求消除非主属性对候选键的传递依赖。比如user表现在组成如下： user_id name classification 仅有 user_id 是主键，用户姓名依赖于主键 user_id，根据姓名 name 来给用户分类，而用户可能重名，因此 name 是允许重复的，再有用户分类 classification 依赖于用户姓名。这张表已经满足了2NF，即属性依赖于全部主键 user_id，但是形成了从 classification 到非候选键 name 再到主键 user_id 的传递依赖，不符合3NF BC范式（BCNF）NF中只是排除了非主属性对候选键的传递依赖，于是更进一步，BCNF还要求消除主属性对候选键在内的传递依赖。 user表现在变成这样： user_id card_id passport_id 其中护照号passport_id是主键，身份证号card_id和用户号user_id都是候选键，存在主属性passport_id到card_id再到候选键user_id的传递依赖。 第四范式（4NF）4NF是要消除多值依赖。 在关系模式中，函数依赖不能表示属性值之间的一对多联系，这些属性之间有些虽然没有直接关系，但存在间接的关系，把没有直接联系、但有间接的联系称为多值依赖的数据依赖。 比如user表： user_id position salary_level user_id是主键，薪水等级salary_level看似被用户id直接确定，但其实薪水等级是根据职位position来确定的，和用户本身无直接关系，这就是多值依赖。 第五范式5NF要求消除连接依赖，并且必须保证数据完整。多值依赖是连接依赖的特殊情况，定义稍复杂。这几种范式已经很少涉及。 在保证数据完整性基础上，通常达到3NF，有时达到2NF已经足够了，追求过高的NF级别会导致混乱的库表，大量的多表连接查询，性能低下。]]></content>
      <categories>
        <category>Database</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[指针问题]]></title>
    <url>%2F2018%2F09%2F14%2F%E6%8C%87%E9%92%88%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[int ptr=(int )(&amp;a+1)问题的探讨12345678910111213main()&#123;int a[5]=&#123;1,2,3,4,5&#125;;int *ptr=(int *)(&amp;a+1);printf("%d,%d",*(a+1),*(ptr-1));&#125;-------------------------------------------Result------------------------------------------------- 2,5 具体解释： *(a+1)中，a表示的是数组a[5]的首地址，也就是a[0]，然后地址加1，即指a[1]，输出为2。 第二个点，*(ptr-1)输出为多少？ 解释如下，&amp;a+1不是首地址+1，系统会认为加了一个整个a数组，偏移了整个数组a的大小（也就是5个int的大小）。所以int ptr=(int )(&amp;a+1);其实ptr实际是&amp;(a[5])，也就是a+5。 原因： &amp;a是数组指针，其类型为int(*)[5]; 而指针加1要根据指针类型加上一定的值，不同类型的指针+1之后增加的大小不同，a是长度为5的int数组指针，所以要加5sizeof(int)，ptr实际是a[5]，但是ptr与（&amp;a+1）类型是不一样的，这点非常重要，所以ptr-1只会减去sizeof(int)，a，&amp;a的地址是一样的，但意思就不一样了，a是数组首地址，也就是a[0]的地址，&amp;a是对象（数组）首地址，a+1是数组下一元素的地址，即a[1],&amp;a+1是下一个对象的地址，即a[5]。]]></content>
      <categories>
        <category>C语言</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[计算机网络面试]]></title>
    <url>%2F2018%2F09%2F11%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%2F</url>
    <content type="text"><![CDATA[TCP与UDP协议区别 TCP是面向连接的；UDP是面向非连接即发送数据之前是不需要建立连接的 TCP提供可靠服务，也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复；UDP尽最大努力交付，不保证可靠交互；TCP通过校验和、重传控制、序号标识、滑动窗口确认实现可靠传输 TCP面向字节流，UDP面向报文 UDP具有较好的实时性，工作效率比TCP高 TCP对系统资源要求较多，UDP对系统资源要求较少 HTTP request的几种类型 GET 获取URL指定的信息。如果URL指定的是文件，则返回文件的内容；若指定的是CGI程序，则返回盖数据的输出数据 POST 从客户端向服务器发送数据 HEAD 和GET基本相同，不过它只返回HTTP消息的头文件，而不返回数据的内容 OPTIONS 用于通知或查询通讯选项 DELETE 删除URL指定的服务器文件 CONNECT 使用代理传输加密时使用的方法 IP地址的分类分类由地址中的头几位来定义：0为A类，10位B类，110为C类，1110位D类，1111位E类 IP = 网络号 + 主机号 A类 0.0.0.0 - 127.255.255.255 B类 128.0.0.0 - 191.255.255.255 C类 192.0.0.0 - 233.255.255.255 D类 224.0.0.0 - 239.255.255.255 E类 240.0.0.0 - 255.255.255.255 OSI协议从上往下依次为：应用层、表示层、会话层、传输层、网络层、数据链路层、物理层 Http与Https区别Http协议运行在TCP之上，明文传输，客户端与服务器端都无法验证对方的身份；Https是身披SSL(Secure Socket Layer)外壳的Http，运行于SSL上，SSL运行于TCP之上，是添加了加密和认证机制的HTTP。二者之间存在如下不同： 端口不同：Http与Http使用不同的连接方式，用的端口也不一样，前者是80，后者是443； 资源消耗：和HTTP通信相比，Https通信会由于加减密处理消耗更多的CPU和内存资源； 开销：Https通信需要证书，而证书一般需要向认证机构购买；Https的加密机制是一种共享密钥加密和公开密钥加密并用的混合加密机制。 TCP协议如何来保证传输的可靠性TCP提供一种面向连接的、可靠的字节流服务。其中，面向连接意味着两个使用TCP的应用（通常是一个客户和一个服务器）在彼此交换数据之前必须先建立一个TCP连接。在一个TCP连接中，仅有两方进行彼此通信；而字节流服务意味着两个应用程序通过TCP链接交换8bit字节构成的字节流，TCP不在字节流中插入记录标识符。 对于可靠性，TCP通过以下方式进行保证： 数据包校验：目的是检测数据在传输过程中的任何变化，若校验出包有错，则丢弃报文段并且不给出响应，这时TCP发送数据端超时后会重发数据； 对失序数据包重排序：既然TCP报文段作为IP数据报来传输，而IP数据报的到达可能会失序，因此TCP报文段的到达也可能会失序。TCP将对失序数据进行重新排序，然后才交给应用层； 丢弃重复数据：对于重复数据，能够丢弃重复数据； 应答机制：当TCP收到发自TCP连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒； 超时重发：当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段； 流量控制：TCP连接的每一方都有固定大小的缓冲空间。TCP的接收端只允许另一端发送接收端缓冲区所能接纳的数据，这可以防止较快主机致使较慢主机的缓冲区溢出，这就是流量控制。TCP使用的流量控制协议是可变大小的滑动窗口协议。 Get与POST的区别 GET与POST是我们常用的两种HTTP Method，二者之间的区别主要包括如下五个方面： (1). 从功能上讲，GET一般用来从服务器上获取资源，POST一般用来更新服务器上的资源； (2). 从REST服务角度上说，GET是幂等的，即读取同一个资源，总是得到相同的数据，而POST不是幂等的，因为每次请求对资源的改变并不是相同的；进一步地，GET不会改变服务器上的资源，而POST会对服务器资源进行改变； (3). 从请求参数形式上看，GET请求的数据会附在URL之后，即将请求数据放置在HTTP报文的 请求头 中，以?分割URL和传输数据，参数之间以&amp;相连。特别地，如果数据是英文字母/数字，原样发送；否则，会将其编码为 application/x-www-form-urlencoded MIME 字符串(如果是空格，转换为+，如果是中文/其他字符，则直接把字符串用BASE64加密，得出如：%E4%BD%A0%E5%A5%BD，其中％XX中的XX为该符号以16进制表示的ASCII)；而POST请求会把提交的数据则放置在是HTTP请求报文的 请求体 中。 (4). 就安全性而言，POST的安全性要比GET的安全性高，因为GET请求提交的数据将明文出现在URL上，而且POST请求参数则被包装到请求体中，相对更安全。 (5). 从请求的大小看，GET请求的长度受限于浏览器或服务器对URL长度的限制，允许发送的数据量比较小，而POST请求则是没有大小限制的。 SQL注入SQL注入就是通过把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。 1). SQL注入攻击的总体思路 (1). 寻找到SQL注入的位置 (2). 判断服务器类型和后台数据库类型 (3). 针对不通的服务器和数据库特点进行SQL注入攻击 2). SQL注入攻击实例 比如，在一个登录界面，要求输入用户名和密码，可以这样输入实现免帐号登录： 12用户名： ‘or 1 = 1 --密 码：12 用户一旦点击登录，如若没有做特殊处理，那么这个非法用户就很得意的登陆进去了。这是为什么呢?下面我们分析一下：从理论上说，后台认证程序中会有如下的SQL语句：String sql = “select from user_table where username=’ “+userName+” ’ and password=’ “+password+” ‘”; 因此，当输入了上面的用户名和密码，上面的SQL语句变成：SELECT FROM user_table WHERE username=’’or 1 = 1 – and password=’’。分析上述SQL语句我们知道，username=‘ or 1=1 这个语句一定会成功；然后后面加两个-，这意味着注释，它将后面的语句注释，让他们不起作用。这样，上述语句永远都能正确执行，用户轻易骗过系统，获取合法身份。 3). 应对方法 (1). 参数绑定 使用预编译手段，绑定参数是最好的防SQL注入的方法。目前许多的ORM框架及JDBC等都实现了SQL预编译和参数绑定功能，攻击者的恶意SQL会被当做SQL的参数而不是SQL命令被执行。在mybatis的mapper文件中，对于传递的参数我们一般是使用#和$来获取参数值。当使用#时，变量是占位符，就是一般我们使用javajdbc的PrepareStatement时的占位符，所有可以防止sql注入；当使用$时，变量就是直接追加在sql中，一般会有sql注入问题。 (2). 使用正则表达式过滤传入的参数 简单解释一些ARP协议的工作过程 首先，每个主机都会在自己的ARP缓冲区中建立一个ARP列表，以表示IP和MAC地址之间的映射关系 当源主机要发送数据时，首先检查ARP列表中是否有对应的IP地址的目的地址的MAC地址，如果有，则直接发送数据；如果没有，就向本网段的所有主机发送ARP数据包，该数据包包括的内容有：源主机IP地址，源主机MAC地址，目的主机IP地址 当本网段的所有主机收到该ARP数据包时，首先检查数据包中的IP地址是否是自己的IP地址，如果不是，则忽略该数据包；如果是，则首先从数据包中取出源主机的IP和MAC地址写入到ARP列表中，如果已经存在，则覆盖，然后将自己的MAC地址写入到ARP响应中，告诉源主机自己是它想要找的MAC地址 源主机接到ARP响应后。将目的主机的MAC地址写入ARP列表，并利用此信息发送数据。如果源主机一直没有收到ARP响应数据包，表示查询失败。]]></content>
      <categories>
        <category>Computer Network</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[python的装饰器与闭包]]></title>
    <url>%2F2018%2F09%2F11%2Fpython%E8%A3%85%E9%A5%B0%E5%99%A8%2F</url>
    <content type="text"><![CDATA[装饰器装饰器的定义装饰器的功能是将被装饰的函数当作参数传递与装饰器对应的函数，并返回包装后被装饰的函数。 假如有个名为decorate的装饰器: 123@decoratedef target(): print("running target()") 上述代码的效果与下述写法一样 123def target(): print("running target")target = decorate(target) 例如： 123456789101112def deco(func): def inner(): print("running inner()") return inner@decodef target(): print("running target" )&gt;&gt;target()running inner()&gt;&gt; target&lt;function deco.&lt;locals&gt;.inner at 0x10063b598&gt; 闭包闭包的定义一个闭包就是你调用了一个函数A，这个函数A返回了一个函数B给你。这个返回的函数B就叫做闭包。你在调用函数A的时候传递的参数就是自由变量。 闭包的作用闭包的最大特点是可以将父函数的变量与内部函数绑定，并返回绑定变量后的函数（也即闭包），此时即便生成闭包的环境（父函数）已经释放，闭包仍然存在，这个过程很像类（父函数）生成实例（闭包），不同的是父函数只在调用时执行，执行完毕后其环境就会释放，而类则在文件执行时创建，一般程序执行完毕后作用域才释放，因此对一些需要重用的功能且不足以定义为类的行为，使用闭包会比使用类占用更少的资源，且更轻巧灵活 闭包与装饰器事实上，装饰器就是闭包的一种应用，只不过传递的是函数 12345678910111213141516171819202122def makebold(fn): def wrapped(): return "&lt;b&gt;" + fn() + "&lt;/b&gt;" return wrappeddef makeitalic(fn): def wrapped(): return "&lt;i&gt;" + fn() + "&lt;/i&gt;" return wrapped@makebold@makeitalicdef hello(): return "hello world"print(hello())---------------------------------------输出-------------------------------------------------------&lt;b&gt;&lt;i&gt;hello world&lt;/i&gt;&lt;/b&gt; @makeitalic 装饰器将函数 hello 传递给函数 makeitalic，函数 makeitalic 执行完毕后返回被包装后的 hello 函数，而这个过程其实就是通过闭包实现的。@makebold 也是如此，只不过其传递的是 @makeitalic 装饰过的 hello 函数，因此最后的执行结果 &lt;b&gt; 在 &lt;i&gt; 外层，这个功能如果不用装饰器，其实就是显式的使用闭包 123456789101112131415161718192021def makebold(fn): def wrapped(): return "&lt;b&gt;" + fn() + "&lt;/b&gt;" return wrappeddef makeitalic(fn): def wrapped(): return "&lt;i&gt;" + fn() + "&lt;/i&gt;" return wrappeddef hello(): return "hello world"hello = makeitalic(hello)hello = makebold(hello)print(hello())---------------------------------------输出-------------------------------------------------------&lt;b&gt;&lt;i&gt;hello world&lt;/i&gt;&lt;/b&gt; 一道python题1234567891011def count(): fs = [] for i in range(1,4): def f(): return i * i fs.append(f) return fsf1,f2,f3 = count()print(f1().f2(),f3())-----------------------------------------------输出-----------------------------------------------9 9 9 解析： count()首先定义了一个列表，然后通过一个for循环给列表添加了3个元素，最后返回了列表，所以我们就知道f1,f2,f3分别代表了这个列表的三个值fs[0],fs[1],fs[2] 我们知道，其实fs中存放的是3个指向f的引用，这个函数的功能就是返回i*i f1(),f2(),f3()就是将这三个函数f分别执行 现在问题又来了，函数f里使用到了i这个变量，这个变量来自于函数f定义时的父函数，并没有来自它本身或者传入他的函数-内部函数引用外部函数的局部变量，就形成了闭包。 关键点： f函数运行了三次，每次保存的是指向f的引用和指向i的引用 运行了3次之后，i的值变为了3 最后运行时，用的i值都为3 多个参数的装饰器简单的装饰器12345678910111213141516171819202122def w1(func): print('w1') def inner(): print("inner1") func() print("inner2") return inner@w1def f1(): print('f1')f1()*************************************Result******************************************w1inner1f1inner2 等价于 1234567891011121314151617def w1(func): print('w1') def inner(): print("inner1") func() print("inner2") return innerdef f1(): print('f1')new_f1 = w1(f1)new_f1() 带参数的装饰器1234567891011121314151617181920212223242526def out_w1(arg): print('out_w1:'+arg) def w1(func): print("w1") def inner(): print("inner1") func() print("inner2") return inner return w1@out_w1('123')def f1(): print('f1')f1()*******************************************Result*************************************************out_w1:123w1inner1f1inner2 等价于： 123456789101112131415161718192021def out_w1(arg): print('out_w1:'+arg) def w1(func): print("w1") def inner(): print("inner1") func() print("inner2") return inner return w1def f1(): print('f1')w1 = out_w1('123')new_f1 = w1(f1)new_f1() 多个装饰器1234567891011121314151617181920212223242526272829303132333435def w1(func): print('w1') def inner(): print("inner1") func() print("inner11") return innerdef w2(func): print('w2') def inner(): print('inner2') func() print('inner22') return inner@w1@w2def f1(): print('f1') f1()******************************************Result*****************w2w1inner1inner2f1inner22inner11 等价于 123456789101112131415161718192021222324252627def w1(func): print('w1') def inner(): print("inner1") func() print("inner11") return innerdef w2(func): print('w2') def inner(): print('inner2') func() print('inner22') return innerdef f1(): print('f1')new_f2 = w2(f1)new_f1 = w1(new_f2)new_f1()]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[python的垃圾回收机制]]></title>
    <url>%2F2018%2F09%2F11%2Fpython%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[Garbage Collection python采用的是引用计数机制为主，标记-清除和分代收集两种机制为辅的策略。 引用计数机制python里每一个东西都是对象，他们的核心就是一个结构体：PyObject 1234typedef struct_object &#123; int ob_refcnt; struct_typeobject *ob_type;&#125; PyObject; PyObject是每个对象必有的内容，其中ob_refcnt就是做为引用计数。当一个对象有新的引用时，它的ob_refcnt就会增加，当引用它的对象被删除，它的ob_refcnt就会减少 当引用计数的值为0时，该对象生命就结束了。 引用计数机制的优点： 简单 实时性：一旦没有了引用，内存就直接释放了。 引用计数的缺点： 维护引用计数消耗资源 循环引用 1234list1 = []list2 = []list1.append(list2)list2.append(list1) list1与list2相互引用，如果不存在其它对象对他们的应用，list1与list2的引用计数也仍然为1，所占用的内存永远无法被回收，这将是致命的。 标记-清除“标记-清除”是为了解决循环引用的问题。可以包含其他对象引用的容器对象（比如：list，set，dict，class，instance）都可能产生循环引用。 原理：“标记-清除”采用了更好的做法，我们并不改动真实的引用计数，而是将集合中对象的引用计数复制一份副本，改动该对象引用的副本。对于副本做任何的改动，都不会影响到对象生命走起的维护。 这个计数副本的唯一作用是寻找root object集合（该集合中的对象是不能被回收的）。当成功寻找到root object集合之后，首先将现在的内存链表一分为二，一条链表中维护root object集合，成为root链表，而另外一条链表中维护剩下的对象，成为unreachable链表。之所以要剖成两个链表，是基于这样的一种考虑：现在的unreachable可能存在被root链表中的对象，直接或间接引用的对象，这些对象是不能被回收的，一旦在标记的过程中，发现这样的对象，就将其从unreachable链表中移到root链表中；当完成标记后，unreachable链表中剩下的所有对象就是名副其实的垃圾对象了，接下来的垃圾回收只需限制在unreachable链表中即可。 分代回收背景：分代的垃圾收集技术是在上个世纪80年代初发展起来的一种垃圾收集机制，一系列的研究表明：无论使用何种语言开发，无论开发的是何种类型，何种规模的程序，都存在这样一点相同之处。即：一定比例的内存块的生存周期都比较短，通常是几百万条机器指令的时间，而剩下的内存块，起生存周期比较长，甚至会从程序开始一直持续到程序结束。 从前面“标记-清除”这样的垃圾收集机制来看，这种垃圾收集机制所带来的额外操作实际上与系统中总的内存块的数量是相关的，当需要回收的内存块越多时，垃圾检测带来的额外操作就越多，而垃圾回收带来的额外操作就越少；反之，当需回收的内存块越少时，垃圾检测就将比垃圾回收带来更少的额外操作。为了提高垃圾收集的效率，采用“空间换时间的策略”。 原理：将系统中的所有内存块根据其存活时间划分为不同的集合，每一个集合就成为一个“代”，垃圾收集的频率随着“代”的存活时间的增大而减小。也就是说，活得越长的对象，就越不可能是垃圾，就应该减少对它的垃圾收集频率。那么如何来衡量这个存活时间：通常是利用几次垃圾收集动作来衡量，如果一个对象经过的垃圾收集次数越多，可以得出：该对象存活时间就越长。]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[java内存区域和内存溢出]]></title>
    <url>%2F2018%2F09%2F10%2Fjava%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E5%92%8C%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%2F</url>
    <content type="text"><![CDATA[内存区域Java虚拟机在执行Java程序的过程中会把他所管理的内存划分为若干个不同的数据区域。Java虚拟机规范将JVM所管理的内存分为以下几个运行时数据区：程序计数器、Java虚拟机栈、本地方法栈、Java堆、方法区。下面详细阐述各数据区所存储的数据类型。 程序计数器程序计数器是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。 由于java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间的计数器互不影响，独立存储，我们称为这类内存区域为“线程私有”的内存。 如果线程正在执行的是一个java方法，这个计数器记录的就是正在执行的虚拟机字节码指令的地址；如果正在执行的是Native方法，这个计数器值则为空。此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。 方法区(Method Area)方法区也是各个线程共享的内存区域，它用于存储已经被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。Java虚拟机规范把方法区描述为Java堆的一个逻辑部分，而且它和Java Heap一样不需要连续的内存，可以选择固定大小或可扩展，另外，虚拟机规范允许该区域可以选择不实现垃圾回收。相对而言，垃圾收集行为在这个区域比较少出现。该区域的内存回收目标主要针是对废弃常量的和无用类的回收。运行时常量池是方法区的一部分，Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池（Class文件常量池），用于存放编译器生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。运行时常量池相对于Class文件常量池的另一个重要特征是具备动态性，Java语言并不要求常量一定只能在编译期产生，也就是并非预置入Class文件中的常量池的内容才能进入方法区的运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用比较多的是String类的intern()方法。 Java堆Java Heap是java虚拟机所管理的内存中最大的一块，它是所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例。几乎所有的对象实例和数组都在这类分配内存。 Java堆垃圾器管理的主要部分，因此很多时候也被称为“GC堆”。如果从内存回收的角度来看，由于现在收集器基本都是采用的是分代收集算法，所以Java堆中还可以细分为：新生代和老年代；再细致一点的有Eden空间、From Survivor空间、To Survivor空间等。 根据Java虚拟机规范的规定，Java堆可以处在物理上不连续的内存空间中，只要逻辑上是连续的即可。如果在堆中没有内存可分配时，并且堆也无法扩展时，将会抛出OutOfMemoryError异常。 本地方法栈(Native Method Stacks)该区域与虚拟机栈所发挥的作用非常相似，只是虚拟机栈为虚拟机执行Java方法服务，而本地方法栈则为使用到的本地操作系统方法服务。 运行时常量池运行时常量池是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述的信息外，还有一项信息是常量池，用于存放编译器生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。 直接内存直接内存并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用，而且可能导致OutOfMemoryError异常出现。 在JDK1.4中新加入了NIO（NEW Input/Output）类，引入了一种基于通道(Channel)与缓冲区(Buffer)的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作，这样能在一些场景中显著提高性能，因此避免了在Java堆和Native堆中来回复制数据。 对象的访问在java中，即使是最简单的java访问，也会涉及java栈、java堆、方法区这三个最重要的内存区域，如下面这句代码： 1Object obj = new Object() 假设这句代码出现在方法体中，那“Object obj”这部分的语义将会反映到Java栈的本地变量表中，作为一个reference类型数据出现。而“new Object()”这部分的语义将会反映到Java堆中，形成一块存储了Object类型所有实例数据值的结构化内存，根据具体类型以及虚拟机实现的对象内存布局的不同，这块内存的长度是不固定的。另外，在Java堆中还必须包含能查找到此对象类型的数据(如对象类型、父类、实现的接口、方法等)的地址信息，这些类型数据则存储在方法区中。 由于reference类型在java虚拟机规范里面只规定了一个指向对象的引用，并没有定义这个引用应该通过哪种方式去定位，以及访问到Java堆中的对象的具体位置，因此不同虚拟机实现的对象访问方式会有所不同，主流的访问方式有两种：使用句柄和直接指针。 如果使用句柄方式访问，Java堆中将会划出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据和类型数据各自的具体地址信息，如图： 如果使用的是直接指针访问方式，Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，reference中直接储存的就是对象的地址，如图 这两钟对象的访问方式各有优势，使用句柄访问方式的最大好处就是reference中存储的是稳定的句柄地址，在对象对移动时只会改变句柄中的实例数据指针，而reference本身不需要被修改。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[静态代码块、构造代码块、构造函数以及Java类的初始化]]></title>
    <url>%2F2018%2F09%2F10%2F%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97%E3%80%81%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97%E3%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%BB%A5%E5%8F%8AJava%E7%B1%BB%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%2F</url>
    <content type="text"><![CDATA[静态代码块：用static声明，JVM加载类时执行，仅执行一次 构造代码块：类中直接用{}定义，每一次创建对象时执行 执行顺序优先级：静态块 &gt; main() &gt; 构造快 &gt; 构造方法 构造函数12public HelloA()&#123; //构造函数&#125; 关于构造函数，以下几点要注意： 对象一建立，就会调用与之相应的构造函数，也就是说，不建立对象，构造函数是不会运行的 构造函数的作用是给对象进行初始化 一个对象建立，构造函数只运行一次，而一般方法可以被该对象调用多次 构造代码块12&#123; //构造代码块&#125; 关于构造代码块，以下几点要注意： 构造代码块的作用是给对象进行初始化 对象一建立就运行构造代码块了，而且优于构造函数执行。这里要强调一下，有对象建立，才会运行构造代码块，类是不能调用构造代码块的，而且构造代码块的执行顺序是先于构造函数执行的。 构造代码块与构造函数的区别是：构造代码块是给所有对象进行统一初始化，而构造函数是给对应的对象初始化，因为构造函数是可以多个的，运行哪个构造函数就会建立什么样的对象，但无论建立哪个对象，都会先执行相同的构造代码块。也就是说，构造代码块中定义的是不同对象共性的初始化内容。 静态代码块123static&#123; //静态代码块 &#125; 关于静态代码块，要注意的是： 它是随着类的加载而执行，只执行一次，并优先于主函数。具体说，静态代码块是由类调用的。类调用时，先执行静态代码块，然后才执行主函数的。 静态代码块其实就是给类初始化的，而构造代码块是给对象初始化的。 静态代码块中的变量是局部变量，与普通函数中的局部变量性质没有区别 一个类中可以有多个静态代码块 1234567891011121314public class Test&#123;staitc int cnt=6;static&#123; cnt+=9;&#125;public static void main(String[] args) &#123; System.out.println(cnt);&#125;static&#123; cnt/=3;&#125;&#125;运行结果：3 Java类初始化顺序对于一个类的情况例1 123456789101112131415public class HelloA &#123; public HelloA()&#123;//构造函数 System.out.println("A的构造函数"); &#125; &#123;//构造代码块 System.out.println("A的构造代码块"); &#125; static &#123;//静态代码块 System.out.println("A的静态代码块"); &#125; public static void main(String[] args) &#123; &#125;&#125;运行结果：A的静态代码块 例2 12345678910111213141516171819public class HelloA &#123; public HelloA()&#123;//构造函数 System.out.println("A的构造函数"); &#125; &#123;//构造代码块 System.out.println("A的构造代码块"); &#125; static &#123;//静态代码块 System.out.println("A的静态代码块"); &#125; public static void main(String[] args) &#123; HelloA a=new HelloA(); &#125;&#125;运行结果：A的静态代码块A的构造代码块A的构造函数 例3 1234567891011121314151617181920212223public class HelloA &#123; public HelloA()&#123;//构造函数 System.out.println("A的构造函数"); &#125; &#123;//构造代码块 System.out.println("A的构造代码块"); &#125; static &#123;//静态代码块 System.out.println("A的静态代码块"); &#125; public static void main(String[] args) &#123; HelloA a=new HelloA(); HelloA b=new HelloA(); &#125;&#125;运行结果：A的静态代码块A的构造代码块A的构造函数A的构造代码块A的构造函数 例4 12345678910111213141516171819202122232425262728293031323334public class InitialOrderTest &#123; /* 静态变量 */ public static String staticField = "静态变量"; /* 变量 */ public String field = "变量"; /* 静态初始化块 */ static &#123; System.out.println( staticField ); System.out.println( "静态初始化块" ); &#125; /* 初始化块 */ &#123; System.out.println( field ); System.out.println( "初始化块" ); &#125; /* 构造器 */ public InitialOrderTest() &#123; System.out.println( "构造器" ); &#125; public static void main( String[] args ) &#123; new InitialOrderTest(); &#125;&#125;------------------------------------------------------------------------------------运行以上代码，可以得到以下输出结果：1. 静态变量2. 静态初始化块3. 变量4. 初始化块5. 构造器 继承的情况例5 当涉及到继承时，按照如下顺序执行： 执行父类的静态代码块，并初始化父类静态成员变量 执行子类的静态代码块，并初始化子类静态成员变量 执行父类的构造代码块，执行父类的构造函数，并初始化父类普通成员变量 执行子类的构造代码块，执行子类的构造函数。并初始化子类普通成员变量 1234567891011121314151617181920212223242526272829303132public class HelloA &#123; public HelloA()&#123;//构造函数 System.out.println("A的构造函数"); &#125; &#123;//构造代码块 System.out.println("A的构造代码块"); &#125; static &#123;//静态代码块 System.out.println("A的静态代码块"); &#125;&#125;public class HelloB extends HelloA&#123; public HelloB()&#123;//构造函数 System.out.println("B的构造函数"); &#125; &#123;//构造代码块 System.out.println("B的构造代码块"); &#125; static &#123;//静态代码块 System.out.println("B的静态代码块"); &#125; public static void main(String[] args) &#123; HelloB b=new HelloB(); &#125;&#125;-------------------------------------运行结果：---------------------------------------A的静态代码块B的静态代码块A的构造代码块A的构造函数B的构造代码块B的构造函数 例6 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970class Parent &#123; /* 静态变量 */ public static String p_StaticField = "父类--静态变量"; /* 变量 */ public String p_Field = "父类--变量"; protected int i = 9; protected int j = 0; /* 静态初始化块 */ static &#123; System.out.println( p_StaticField ); System.out.println( "父类--静态初始化块" ); &#125; /* 初始化块 */ &#123; System.out.println( p_Field ); System.out.println( "父类--初始化块" ); &#125; /* 构造器 */ public Parent() &#123; System.out.println( "父类--构造器" ); System.out.println( "i=" + i + ", j=" + j ); j = 20; &#125;&#125;public class SubClass extends Parent &#123; /* 静态变量 */ public static String s_StaticField = "子类--静态变量"; /* 变量 */ public String s_Field = "子类--变量"; /* 静态初始化块 */ static &#123; System.out.println( s_StaticField ); System.out.println( "子类--静态初始化块" ); &#125; /* 初始化块 */ &#123; System.out.println( s_Field ); System.out.println( "子类--初始化块" ); &#125; /* 构造器 */ public SubClass() &#123; System.out.println( "子类--构造器" ); System.out.println( "i=" + i + ",j=" + j ); &#125; /* 程序入口 */ public static void main( String[] args ) &#123; System.out.println( "子类main方法" ); new SubClass(); &#125;&#125;---------------------------------------结果------------------------------------------ 父类-静态变量 父类--静态初始化块 子类--静态变量 子类--静态初始化块 子类main方法 父类--变量 父类--初始化块 父类--构造器 i=9，j=0 子类--变量 子类--初始化块 子类--构造器 i=9,j=20 注： 引自：https://www.cnblogs.com/Qian123/p/5713440.html]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[python函数]]></title>
    <url>%2F2018%2F09%2F09%2Fpython%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[isalnum()描述isalnum()方法检测字符串是否由字母和数字组成 语法str.isalnum() 返回值如何string至少有一个字符且所有字符都是字母则返回True，否则返回False 123456789str = "this2009"print("str.isalnum")-------------------------Truestr = "this is string example....wow!!!";print str.isalnum();---------------------------Flase]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>isalnum</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库的主从复制]]></title>
    <url>%2F2018%2F09%2F09%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%2F</url>
    <content type="text"><![CDATA[什么是主从复制MySQL复制是指从一个MySQL主服务器(master)将数据复制到另一台或者多台MySQL从服务器(slaves)的过程，将主数据库的DDL和DML操作通过二进制日志传到复制服务器上，然后从服务器上对这些日志重新执行，从而使得主从服务器的数据保持同步。 主从复制的作用 做数据的热备，作为后备数据库，主数据库服务器故障后，可切换到从数据库继续工作，避免数据丢失。 架构的扩展。业务量越来越大，I/O访问频率过高，单机无法满足，此时做多库的存储，降低磁盘I/O访问的频率，提高单个机器的I/O性能。 读写分离，使数据库能支撑更大的并发。在报表中尤其重要。由于部分报表sql语句非常的慢，导致锁表，影响前台服务。如果前台使用master，报表使用slave，那么报表sql将不会造成前台锁，保证了前台速度。 主从复制的原理 主数据库将数据的改变记录到二进制日志(binary log)中 从服务器将主服务器的binary log events复制到它的中继日志(relay log)中 从服务器重做中继日志中的事件，将数据的改变与从服务器保持同步。 首先，主服务器会记录二进制日志，每个事务更新数据完成之前，主服务器将这些操作的信息记录在二进制日志中，在事件写入二进制日志完成后，主服务器通知存储引擎提交事务 slave上面的I/O进程连接上Master，并发出日志请求，Master接受到来自Slave的I/O进程的请求后，通过负责复制的I/O进程根据请求信息读取与制定日志指定位置之后的日志信息，返回给Slave的I/O进程。返回信息中除了日志所包含的信息之外，还包括本次返回的信息已经到Master端的bin-log文件的名称以及bin-log的位置。 Slave的I/O进程接受到信息后，将接受到的日志内容依次添加到Slave端的relay-log文件的最末端，并将读取到Master端的bin-log的文件名和位置记录到master-info文件中 Slave的SQL进程检测到relay-log中新增内容后，会马上解析relay-log的内容成为在Master端真实执行时候的那些可执行的内容，并在自身执行。 对于每一个主从复制的连接，都有三个线程。拥有多个从库的主库为每一个连接到主库的从库创建一个连接到bin-log的输出线程，每一个从库都有它自己的I/O线程和SQL线程 主从复制如图： 步骤一：主库db的更新时间(update,insert,delete)被写到binlog 步骤二：从库发起连接，连接到主库 步骤三：此时的主库创建一个binlog dump thread，把bin-log内容发送到从库 步骤四：从库启动之后，创建一个I/O线程，读取主库传过的bin-log内容并写入到relaylog 步骤五：还会创建一个SQL线程，从relay log里面读取内容，从Exec_Master_Log_Pos位置开始执行读取到的更新事件，将更新内容写入到slave的db]]></content>
      <categories>
        <category>Database</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[触发器]]></title>
    <url>%2F2018%2F09%2F08%2F%E8%A7%A6%E5%8F%91%E5%99%A8%2F</url>
    <content type="text"><![CDATA[什么是触发器触发器是与表有关的数据库对象，在满足定义条件时触发，并执行触发器中定义的语句集合 触发器特性 有begin end体，begin end之间的语句可以写的简单或者复杂 什么条件会触发：I，D，U 什么时候触发：增删改前或者后 触发频率：针对每一行执行 触发器定义在表上 也就是由事件来触发某个操作，事件包括INSERT语句、UPDATE语句和DELETE语句；可以协助应用在数据库端确保数据的完整性。 触发器的创建创建只有一个执行语句的触发器12345CREATE TRIGGER 触发器名 BEFORE|AFTER 触发事件 ON 表名 FOR EACH ROW 执行语句;-----------------------------------------------------------------------------mysql&gt; CREATE TRIGGER trig1 AFTER INSERT -&gt; ON work FOR EACH ROW -&gt; INSERT INTO VALUES(NOW()) 创建有多个执行语句的触发器12345678910111213CREATE TRIGGER 触发器名 BEFORE|AFTER 触发事件 ON 表名 FOR EACH ROWBEGIN 执行语句列表END;-------------------------------------------------------------------------------------mysql&gt; CREATE TRIGGER trig2 BEFORE DELETE -&gt; ON work FOR EACH ROW -&gt; BEGIN -&gt; INSERT INTO VALUES(NOW()) -&gt; INSERT INTO VALUES(NOW()) -&gt;end|| mysql&gt; DELIMITER;]]></content>
      <categories>
        <category>Database</category>
      </categories>
      <tags>
        <tag>触发器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL数据库的基本操作]]></title>
    <url>%2F2018%2F09%2F08%2FMySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[数据库操作显示所数据库1show databases; 创建数据库1create database 数据库名 character set utf8; 删除数据库1drop database 数据库名; 切换数据库12# 数据表属于数据库，在创建数据表之前，应该使用如下语句use 数据库名; 查看当前是在哪个数据库1select database(); 表操作查看数据库中所有的表1show tables; 创建表123456789101112# auto_incrementcreate table students(id int auto_increment primary key,sname varchar(10) not null);----------------------------------------------------------------------------------sql&gt;CREATE TABLE STAFF -&gt;( -&gt;id INT NOT NULL AUTO_INCREMENT PRIMARY KEY, -&gt;name VARCHAR(40) NOT NULL, -&gt;dept VARCHAR(40) NOT NULL, -&gt;salary INT NOT NULL, -&gt;edlevel INT NOT NULL, -&gt;hiredata DATE -&gt;); 注释 字段使用NOT NULL 属性，是因为我们不希望这个字段的值为NULL.因此，如果用户将尝试创建具有NULL值的记录，那么MySQL灰产生错误 字段的AUTO_INCREMENT属性告诉MySQL自动增加id字段下一个可用编号 关键字PRIMARY KEY用于定义此列作为主键，可以使用逗号分隔多个列来定义主键 修改表123alter table 表名 add|change|drop 列名 类型;# 例如alter table students add birthday datetime; 查看表的结构1desc 表名； 更改表的名称1rename table 原表名 to 新表名; 数据操作查询1select * from 表名； 增加123456insert into 表名 values(...)## 例如：mysql&gt; insert into students -&gt; (sname,score) -&gt; values -&gt; (&quot;Jack&quot;,91); 修改123456update 表名 set 列1= 值1,...,where id = 4;# 把某一列的值加1mysql&gt;update students -&gt;set -&gt;score = score + 1 -&gt;where id = 1; 删除1delete from [表名] where 条件； 查询GROUP_BYgroup by可以根据给定数据列的每个成员对查询结果进行分组统计，最终得到一个分组汇总表。 123456789id name dept salary edlevel hiredate 1 张三 开发部 2000 3 2009-10-11 2 李四 开发部 2500 3 2009-10-01 3 王五 设计部 2600 5 2010-10-02 4 王六 设计部 2300 4 2010-10-03 5 马七 设计部 2100 4 2010-10-06 6 赵八 销售部 3000 5 2010-10-05 7 钱九 销售部 3100 7 2010-10-07 8 孙十 销售部 3500 7 2010-10-06 1SELECT DEPT,MAX(SALARY) AS MAXIMUM FORM STAFF GROUP BY DEPT; 得到如下结果 1234DEPT MAXIMUN开发部 2500设计部 2600销售部 3500 ORDER BY当使用SELECT语句查询表中的数据时，结果集不按任何顺序进行排序。要对结果集进行排序，请使用ORDER BY子句。子句允许： 对单个列或多个列排序结果集 按升序或降序对不同列的结果集进行排序 1SELECT column1,column2,... FROM tb1 ORDERBY column1 [ASC|DESC], column2 [ASC|DESC],... ASC表示升序，DESC表示降序，默认情况下，如果不明确指定ASC或DESC，ORDER BY子句会按照升序对结果集进行排序。 聚合函数查询COUNT()函数COUNT()函数用于进行计数。 COUNT()函数有两种使用方式。 12345678910111213141516# 第一种 # 使用COUNT(*)对表中行的数目进行计数，不管表列中包含的是空值(NULL)还是非空值SELECT COUNT(*) AS num_cust FROM Customers;输出： num_cust---------5# 第二种# 使用COUNT(column)对特定列中具有值的行进行计数，忽略NULL值SELECT COUNT(cust_email) AS num_cust FROM Customers;输出num_cust-----------3 MAX()函数MAX()返回指定列中的最大值，MAX()要求指定列名 12345SELECT MAX(prod_price) AS max_price FROM Products;输出：max_price-----------11.9900 MIN()函数MIN()的功能正好与MAX()功能相反，它返回指定列的最小值，与MAX()一样，MIN()要求指定列名 12345SELECT MIN(prod_price) AS min_price FROM Products;输出：min_price-----------3.4900 SUM()函数SUM()用来返回指定列值的和 1SELECT SUM(quantity) AS items_ordered FROM OrderItems WHERE order_num = 20005; AVG()函数AVG()通过对表中行数计数并计算其列值之和，求得该列的平均值 12345SELECT AVG(prod_price) AS avg_price FROM Products;输出avg_price----------6.82333]]></content>
      <categories>
        <category>Database</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python字符串与列表转换]]></title>
    <url>%2F2018%2F09%2F07%2FPython%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8E%E5%88%97%E8%A1%A8%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[字符串转列表描述Python split() 通过指定分隔符对字符串进行切片，如果参数 num 有指定值，则仅分隔 num 个子字符串. 语法1str.split(str="", num=string.count(str)). 12345str1 = "Hi Hello World"print(str1.split(" "，1))-------------------------------------------------------------------------------------输出['Hi','Hello World'] 列表转字符串描述Python join() 方法用于将序列中的元素以指定的字符连接生成一个新的字符串。 语法1str.join(sequence) 123l = ["hi", "hello", "world"]print(" ".join(l))--------------------------------------------------------------------------------------------------hi hello world]]></content>
  </entry>
  <entry>
    <title><![CDATA[数据库索引]]></title>
    <url>%2F2018%2F09%2F06%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%2F</url>
    <content type="text"><![CDATA[何为索引索引是对数据库表中一列或多列的值进行排序的一种结构，使用索引可提高数据库中特定数据的查询速度。 索引的优点 通过创建唯一索引，可以保证数据库表中每一行数据的唯一性 可以大大加快数据的查询速度，这也是创建索引的最主要原因 在实现数据的参考完整性方面，可以加速表与表之间的连接 在使用分组和排序字句进行数据查询时，也可以显著减少查询中分组和排序的时间 增加索引的不利方面 创建索引和维护索引要耗费时间，并且随着数据量的增加所耗费的时间也是增加的 索引需要占用物理空间，除了数据表占数据空间外，每一个索引还要占一定的物理空间，如果有大量的索引，索引文件可能比数据文件更快达到最大文件尺寸 当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。 索引建立的规则 在经常需要搜索的列上，可以加快搜索的速度； 在作为主键的列上，强制该列的唯一性和组织表中数据的排列结构； 在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度。 在经常需要排序的列上创 建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间； 在经常用在连接的列上，这 些列主要是一些外键，可以加快连接的速度； 对于那些在查询中很少使用或者参考的列不应该创建索引。 对于那 些只有很少数据值的列也不应该增加索引。 对于那些定义为text, image和bit数据类型的列不应该增加索引。 当修改性能远远大于检索性能时，不应该创建索 引。 索引的分类按照数据结构和使用的算法划分B+ TreeHash索引按照类型划分普通索引、唯一索引和主键索引普通索引是MySQL中的基本索引类型，允许在定义索引的列中插入重复值和空值 唯一索引，索引列的值必须唯一，但允许有空值 主键索引是一种特殊的唯一索引，不允许有空值 单列索引和组合索引单列索引即一个索引只包含单个列，一个表可以有多个单列索引 组合索引指在表的多个字段组合上创建的索引，只有在查询条件中使用了这些字段的左边的字段时，索引才会被使用。 全文索引全文索引类型为FULLTEXT，在定义索引的列上支持值的全文查找，允许在这些索引列中插入重复值和空值。 空间索引空间索引是对空间数据类型的字段建立的索引，MySQL中的空间数据类型有4钟，分别是：GEOMETRY,POINT,LINESTRING和POLYGON。 假设我们有一个数据库表Employee，这个表由三个字段，分别是Employee_Name, Employee_Age和Employee_Address。假设表有上千行数据。 现在假设我们要从这个表中查找出所有名字是‘Jesus’的雇员信息。我们决定使用下面的查询语句： 1SELECT * FROM Employee WHERE Employee_Name = &apos;Jesus&apos; 如果表中没有所以会发生什么？ 一旦我们运行这个查询，在查找名字为Jesus的雇员的过程中，究竟会发生什么？数据库不得不Employee表中的每一行并确定雇员的名字（Employee_Name）是否为 ‘Jesus’。由于我们想要得到每一个名字为Jesus的雇员信息，在查询到第一个符合条件的行后，不能停止查询，因为可能还有其他符合条件的行。所以，必须一行一行的查找直到最后一行-这就意味数据库不得不检查上千行数据才能找到所以名字为Jesus的雇员。这就是所谓的全表扫描。 数据库索引是怎样提升性能的？ 你可能会想为如此简单的事情做全表扫描效率欠佳-数据库是不是应该更聪明一点呢？这就像用人眼从头到尾浏览整张表-很慢也不优雅（原文：not at all sleek，不知如何翻译才好）。但是，你可以能根据文章标题已经猜到，这就是索引派上用场的时候。使用索引的全部意义就是通过缩小一张表中需要查询的记录/行的数目来加快搜索的速度。 什么是索引？ 一个索引是存储的表中一个特定列的值数据结构（最常见的是B-Tree）。索引是在表的列上创建。所以，要记住的关键点是索引包含一个表中列的值，并且这些值存储在一个数据结构中。请记住记住这一点：索引是一种数据结构 。 什么样的数据结构可以作为索引？ B-Tree 是最常用的用于索引的数据结构。因为它们是时间复杂度低， 查找、删除、插入操作都可以可以在对数时间内完成。另外一个重要原因存储在B-Tree中的数据是有序的。数据库管理系统（RDBMS）通常决定索引应该用哪些数据结构。但是，在某些情况下，你在创建索引时可以指定索引要使用的数据结构。 哈希表索引是怎么工作的？ 哈希表是另外一种你可能看到用作索引的数据结构-这些索引通常被称为哈希索引。使用哈希索引的原因是，在寻找值时哈希表效率极高。所以，如果使用哈希索引，对于比较字符串是否相等的查询能够极快的检索出的值。例如之前我们讨论过的这个查询(SELECT * FROM Employee WHERE Employee_Name = ‘Jesus’) 就可以受益于创建在Employee_Name 列上的哈希索引。哈系索引的工作方式是将列的值作为索引的键值（key），和键值相对应实际的值（value）是指向该表中相应行的指针。因为哈希表基本上可以看作是关联数组，一个典型的数据项就像“Jesus =&gt; 0x28939″，而0x28939是对内存中表中包含Jesus这一行的引用。在哈系索引的中查询一个像“Jesus”这样的值，并得到对应行的在内存中的引用，明显要比扫描全表获得值为“Jesus”的行的方式快很多。 哈希索引的缺点 哈希表是无顺的数据结构，对于很多类型的查询语句哈希索引都无能为力。举例来说，假如你想要找出所有小于40岁的员工。你怎么使用使用哈希索引进行查询？这不可行，因为哈希表只适合查询键值对-也就是说查询相等的查询（例：like “WHERE name = ‘Jesus’）。哈希表的键值映射也暗示其键的存储是无序的。这就是为什么哈希索引通常不是数据库索引的默认数据结构-因为在作为索引的数据结构时，其不像B-Tree那么灵活 还有什么其他类型的索引？ 使用R-Tree作为数据结构的索引通常用来为空间问题提供帮助。例如，一个查询要求“查询出所有距离我两公里之内的星巴克”，如果数据库表使用R- Tree索引，这类查询的效率将会提高。另一种索引是位图索引（bitmap index）， 这类索引适合放在包含布尔值(true 和 false)的列上，但是这些值（表示true或false的值）的许多实例-基本上都是选择性（selectivity）低的列。 索引是怎么提升性能的？ 因为索引基本上是用来存储列值的数据结构，这使查找这些列值更加快速。如果索引使用最常用的数据结构-B-Tree-那么其中的数据是有序的。有序的列值可以极大的提升性能。下面解释原因。 假设我们在 Employee_Name这一列上创建一个B-Tree索引。这意味着当我们用之前的SQL查找姓名是‘Jesus’的雇员时，不需要再扫描全表。而是用索引查找去查找名字为‘Jesus’的雇员，因为索引已经按照按字母顺序排序。索引已经排序意味着查询一个名字会快很多，因为名字少字母为‘J’的员工都是排列在一起的。另外重要的一点是，索引同时存储了表中相应行的指针以获取其他列的数据。 数据库索引里究竟存的是什么？ 你现在已经知道数据库索引是创建在表的某列上的，并且存储了这一列的所有值。但是，需要理解的重点是数据库索引并不存储这个表中其他列（字段）的值。举例来说，如果我们在Employee_Name列创建索引，那么列Employee_Age和Employee_Address上的值并不会存储在这个索引当中。如果我们确实把其他所有字段也存储在个这个索引中，那就成了拷贝一整张表做为索引-这样会占用太大的空间而且会十分低效。 索引存储了指向表中某一行的指针 如果我们在索引里找到某一条记录作为索引的列的值，如何才能找到这一条记录的其它值呢？这是很简单 - 数据库索引同时存储了指向表中的相应行的指针。指针是指一块内存区域， 该内存区域记录的是对硬盘上记录的相应行的数据的引用。因此，索引中除了存储列的值，还存储着一个指向在行数据的索引。也就是说，索引中的Employee_Name这列的某个值（或者节点）可以描述为 (“Jesus”, 0x82829)， 0x82829 就是包含 “Jesus”那行数据在硬盘上的地址。如果没有这个引用，你就只能访问到一个单独的值（“Jesus”），而这样没有意义，因为你不能获取这一行记录的employee的其他值-例如地址（address）和年龄（age）。 数据库怎么知道什么时候使用索引？ 当这个SQL （SELECT * FROM Employee WHERE Employee_Name = ‘Jesus’ ）运行时，数据库会检查在查询的列上是否有索引。假设Employee_Name列上确实创建了索引，数据库会接着检查使用这个索引做查询是否合理 - 因为有些场景下，使用索引比起全表扫描会更加低效。如果想要了解更多这些场景，请阅读这篇文章：Selectivity in SQL 你能强制数据库使用索引吗？ 通常来说， 你不会告诉数据库什么时候使用索引 - 数据库自己决定。然而，值得注意的是在大多数数据库中（像Oracle 和 MYSQL）， 你实际上可以制订你想要使用的索引。 如何在使用SQL创建索引 之前的例子中，在Employee_Name列上创建索引的SQL如下： 12CREATE INDEX name_indexON Employee (Employee_Name)12 如何创建联合索引 我们可以在雇员表上创建两个列的联合索引，SQL如下： 12CREATE INDEX name_indexON Employee (Employee_Name, Employee_Age)12 把数据库索引类比成什么比较好呢? 一个非常好的类比是把数据库索引看作是书的索引。如果你有一本关于狗的书，你想要找关于‘黄金猎犬’的那部分。当你可以通过在书背的索引找到哪几页有关于‘黄金猎犬’信息的时候，你为什么要翻完正本书 - 这相当于数据库中的全表扫描。同样的，就像一本书的索引包含页码一样，数据库的索引包含了指针，指向你在SQL中想要查询的值所在的行。 使用数据库索引会有什么代价？ 那么，使用数据库索引有什么缺点呢？其一，索引会占用空间 - 你的表越大，索引占用的空间越大。其二，性能损失（主要值更新操作），当你在表中添加、删除或者更新行数据的时候， 在索引中也会有相同的操作。记住：建立在某列（或多列）索引需要保存该列最新的数据。]]></content>
      <categories>
        <category>Database</category>
      </categories>
      <tags>
        <tag>Index</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python中类的继承及__init__初始化和super方法]]></title>
    <url>%2F2018%2F09%2F03%2Fpython%E4%B8%AD%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF%E5%8F%8A-init-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8Csuper%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Python中__name__==__main__作用]]></title>
    <url>%2F2018%2F09%2F02%2FPython%E4%B8%AD-name-main-%E4%BD%9C%E7%94%A8%2F</url>
    <content type="text"><![CDATA[在Python模块中，我们经常会看见if __name__ == &#39;__main__&#39;这样的代码，那么其作用到底是什么呢？ 其意思是说：该模块既可以被导入Python shell或者其它模块中去，也可以作为脚本来执行。 __name__属性所有模块都有一个内置的属性__name__，__name__的值取决于如何使用这个模块 例如，又一个名为calc.py的模块，包含以下代码 1print('__name__:',__name__) 当导入模块时，__name__是模块的文件名： 12&gt;&gt;&gt;import calc__nama__: calc 但是，如果将其作为脚本使用，_name__就是一个特殊的值 **\_main__** 12$python calc.py__name__: __main__ 由此，可以得出一个结论：当模块被导入时，模块名称是文件名；而当模块作为脚本独立运行时，名称为 main。 让模块即可导入又可执行calc.py模块，内容如下 123def add(a,b): return a + bprint('test:2+3=',add(2+3)) 将其作为模块导入： 12&gt;&gt;&gt;import calctest:2+3=5 在将其作为脚本执行: 12$ python calc.pytest:2+3=5 显然，无论使用哪种方式，都会执行打印语句 如果模块只会被用作脚本，那没什么问题，但若希望将其作为一个导入模块时，往往不想打印出测试用例。在这种情况下，__name__就派上用场了 完善 calc.py 模块，为其添加一个 if 语句： 1234def add(a,b): return a + bif __name__ == '__main__': print('test:2+3=',add(2,3)) 这时，再导入模块，不会执行任何打印语句: 1&gt;&gt;&gt;import calc 而将其作为脚本运行，却可以正常打印]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python的实例属性与类属性]]></title>
    <url>%2F2018%2F09%2F02%2FPython%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%B1%9E%E6%80%A7%E4%B8%8E%E7%B1%BB%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[申明: 此文章引用于:https://segmentfault.com/a/1190000002671941 123456789101112131415class Animal(object): number = 1 # situation 1animal1 = Animal()animal2 = Animal()print(animal1.number,animal2.number,Animal.number)# situation 2animal1.number += 2print(animal1.number,animal2.number,Animal.number)# situation 3Animal.number += 3print(animal1.number,animal2.number,Animal.number) situation1：1 1 1situation2：3 1 1situation3：3 4 4 number属性被称为类属性，既然是类属性，那么根据从C++/Java这种静态语言使用的经验来判断，类属性应该是为其实例所共享的。很自然的，既然是共享关系，那么从类的层次改变number的值，自然其实例的number的值也要跟着变化了。 可是情形3的情况却说明，上面的说法是错的。 错哪里呢？ 要从Python的类属性讲起。 Python类的属性Python属于动态强类型的语言，在很多地方和静态语言不同，因此，不能把静态语言的规则套到动态语言上来。其中，类属性就是一个很好的例子。 对于属性，我们通常采用类.属性或实例.属性的形式调用。 Python中属性的设置对于属性的设置我们通常采用类.属性 = 值或实例.属性 = 值的形式例如animal1.number = 1 上例中animal1.number += 2等价于animal1.number = animal.number + 2，这句话包含了属性获取及属性设置两个操作 OK，重点来了，Python中属性的获取和设置的机制与静态语言是不同的，正是背后机制的不同，导致了Python中类属性不一定是为其实例所共享的 Python中属性的查找机制Python中属性的获取存在一个向上查找机制，还是拿上面的例子做说明： Python中一切皆对象，Aniaml属于类对象，animal1属于实例对象，从对象的角度来看，Animal与animal1是两个无关的对象，但是，Python通过下面的查找树建立了类对象AAA与实例对象obj1、obj2之间的关系。 如图所示: 12345 Animal | --------------- | |animal1 animal2 当调用Animal.number时，直接从Animal获取其属性number 但是情形1中调用animal1.number时，Python按照从animal1到Animal的顺序由下到上查找属性number。 值得注意的这时候animal1是没有属性number的，于是，Python到类Animal中去查找，成功找到，并显示出来。所以，从现象上来看，Animal的属性number确实是共享给其所有实例的，虽然这里只是从查找树的形式模拟了其关系。 Python中的属性设置上面我们指出animal1.number += 2包含了属性获取及属性设置两个操作。 即animal1.number += 2等价于animal1.number = animal1.number + 2。 其中等式右侧的animal1.number属于属性获取，其规则是按照上面提到的查找规则进行，即，这时候，获取到的是Animal的属性number，所以等式左侧的值为3。 第二个操作是属性设置，即animal1.number = 3。当发生属性设置的时候，animal1这个实例对象没有属性，因此会为自身动态添加一个属性number。 由于从对象的角度，类对象和实例对象属于两个独立的对象，所以，这个number属性只属于animal1，也就是说，这时候类对象Animal和实例对象animal1各自有一个属性number。 那么，在情形3中，再次调用animal1.number时，按照属性调用查找规则，这个时候获取到的是实例对象animal1的属性number，而不是类对象Animal的属性number。 问题总结 Python中属性的获取是按照从下到上的顺序来查找顺序 Python中的类和实例是两个完全独立的对象 Python中的属性设置是针对对象本身进行的]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象编程]]></title>
    <url>%2F2018%2F09%2F02%2Fpython%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[类和对象的通俗理解实例继承和多态在面向对象程序设计中，当我们定义一个class的时候，可以从某个现有的class继承，新的class称为子类（subclass），而被继承的class称为父类或者基类。 继承1234567891011121314class Animal: def run(self): print("Animal is running!")class Gog(Animal): def go(self): print("Go!")if __name__ == '__main__': dog = Dog() dog.run() dog.go()----------------------------------------------------------------------------Animal is running!Go! 对于Dog来说，Animal就是它的父类，对于Animal来说，Dog就是它的子类。 子类获得了父类的全部功能。Dog类继承了父类的run功能，可以给自己的实例直接用。 多态但是，如果父类与子类同时含有run()方法呢？如下： 123456789101112class Animal: def run(self): print("Animal is running!")class Dog(Animal): def run(self): print("Go!")if __name__ == '__main__': dog = Dog() dog.run()-------------------------------------------------------------------------------Go! 子类的方法如果和父类的方法同名，子类的方法会覆盖掉父类的方法。 实例属性和类属性]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象编程]]></title>
    <url>%2F2018%2F09%2F02%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[类和对象实例继承和多态在面向对象程序设计中，当我们定义一个class的时候，可以从某个现有的class继承，新的class称为子类（subclass），而被继承的class称为父类或者基类。 继承1234567891011121314class Animal: def run(self): print("Animal is running!")class Gog(Animal): def go(self): print("Go!")if __name__ == '__main__': dog = Dog() dog.run() dog.go()----------------------------------------------------------------------------Animal is running!Go! 对于Dog来说，Animal就是它的父类，对于Animal来说，Dog就是它的子类。 子类获得了父类的全部功能。Dog类继承了父类的run功能，可以给自己的实例直接用。 继承中的__init__当在Python中出现继承情况时，一定要注意初始化函数__init__的行为： 如果子类没有定义自己的初始化函数，父类的初始化函数会被默认调用；但是如果要实例话子类的对象，则只能传入父类的初始化函数对应的参数，否则会出错 如果子类定义了自己的初始化函数，而在子类中没有显示的调用父类的初始化函数，则父类的属性不会被初始化 如果子类定义了自己的初始化函数，在子类中显示调用父类，子类和父类的属性都会被初始化 子类没有定义自己的初始化函数1234567891011121314151617# 定义父类：Parentclass Parent(object): def __init__(self,name): self.name = name print("Create an instance of: ",self.__class__.__name__) print("name attribute is:",self.name)# 定义子类：Child class Child(Parent): pass#子类实例化时，由于子类没有初始化，此时父类的初始化函数就会默认被调用#且必须传入父类的参数namec = Child("init Child")------------------------------------------------------------------------------------输出结果：Create an instance of: Childname attribute is: init Child 子类实例化时，由于子类没有初始化，此时父类的初始化函数就会默认被调用 若子类在实例化时未传入参数，则会报错，如下： 12345Traceback (most recent call last): File "C:\Users\benbo\Desktop\te\t3.py", line 12, in &lt;module&gt; c = Child()TypeError: __init__() missing 1 required positional argument: 'name'[Finished in 0.2s] 子类定义了自己的初始化函数子类定义了自己的初始化函数，而在子类中没有显示调用父类的初始化函数，则父类的属性不会被初始化 12345678910111213141516171819202122# 定义父类：Parentclass Parent(object): def __init__(self,name): self.name = name print("Create an instance of: ",self.__class__.__name__) print("name attribute is: ", self.name)# 定义子类：Child class Child(Parent): def __init__(self): print("call __init__ from Child class")c = Child()print(c.name)------------------------------------------------------------------------------------输出：call __init__ from Child classTraceback (most recent call last): File "C:\Users\benbo\Desktop\te\t3.py", line 13, in &lt;module&gt; print(c.name)AttributeError: 'Child' object has no attribute 'name'[Finished in 0.2s] 在子类中没有显示调用父类的初始化函数，则父类的属性不会被初始化，因而此时调用子类中name属性不存在。 子类在初始化函数中显示调用了父类在子类中定义了自己的初始化函数，显示调用父类，子类和父类的属性都会被初始化 123456789101112131415161718192021222324# 定义父类：Parentclass Parent(object): def __init__(self,name): self.name = name print("Create an instance of: ",self.__class__.__name__) print("name attribute is: ", self.name)# 定义子类：Child class Child(Parent): def __init__(self): print("call __init__ from Child class") super().__init__("data from Child")d= Parent("Tom")c = Child()print(c.name)------------------------------------------------------------------------------------输出结果：Create an instance of: Parentname attribute i Tos: mcall __init__ from Child classCreate an instance of: Childname attribute is: data from Childdata from Child[Finished in 0.2s] super方法在类的继承中，如果重定义某个方法，该方法会覆盖父类的同名方法，但有时，我们希望能同时实现父类的功能，这时，我们就需要调用父类的方法了，可通过使用 super 来实现，比如： 12345678910111213141516171819class Animal(object): def __init__(self,name): self.name = name def greet(self): print("Hello,I am &#123;&#125;".format(self.name))class Dog(Animal): def greet(self): super().greet() print("WangWang...") if __name__ == "__main__": dog = Dog() dog.greet() ----------------------------------------------------------------------------Hello,I am dogWangWang...[Finished in 0.2s] super的一个常见用法可以说是在子类中调用父类的初始化方法了，比如： 12345678class Base(object): def __init__(self,a,b): self.a = a self.b = bclass A(Base): def __init__(self,a,b,c): super().__init__(a,b) self.c = c 但是，如果父类与子类同时含有run()方法呢？如下： 123456789101112class Animal: def run(self): print("Animal is running!")class Dog(Animal): def run(self): print("Go!")if __name__ == '__main__': dog = Dog() dog.run()-------------------------------------------------------------------------------Go! 子类的方法如果和父类的方法同名，子类的方法会覆盖掉父类的方法。 实例属性和类属性]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python的format格式化函数]]></title>
    <url>%2F2018%2F09%2F02%2FPython%E7%9A%84format%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[format是python2.6新增的一个格式化字符串的方法，相对于老版的%格式方法，它有很多优点。 不需要理会数据类型的问题，在%方法中%s只能替代字符串类型 单个参数可以多次输出，参数顺序可以不相同 填充方式十分灵活，对齐方式十分强大 官方推荐用的方式，%方式将会在后面的版本被淘汰 format填充字符串通过位置来填充字符串1234567891011# 设置指定位置&gt;&gt;&gt;print("hello &#123;0&#125;,i am &#123;1&#125;".format('world','Python'))hello world,i am Python# 不设置指定位置&gt;&gt;&gt;print("hello &#123;&#125;,i am &#123;&#125;".format("world","Python"))hello world,i am Python# 设置指定位置&gt;&gt;&gt;print("&#123;1&#125; &#123;0&#125; &#123;1&#125;".format("hello","world"))world hello world 通过key来填充1234567&gt;&gt;&gt;obj = 'world'&gt;&gt;&gt;name = 'python'&gt;&gt;&gt;print('hello &#123;obj&#125;,i am &#123;name&#125;'.format(obj = obj,name=name))hello world,i am python&gt;&gt;&gt;print("网站名：&#123;name&#125;,地址：&#123;url&#125;".format(name="菜鸟",url='www.runoob.com'))网站名：菜鸟,地址：www.runoob.com 通过列表填充123&gt;&gt;&gt;list = ['world','python']&gt;&gt;&gt;print('hello &#123;name[0]&#125;, i am &#123;name[1]&#125;'.format(name=list))hello world, i am python format格式转换 数字 格式 输出 描述 3.1415926 {:.2f} 3.14 保留小数点后两位 3.1415926 {:+.2f} 3.14 带符号保留小数点后两位 -1 {:+.2f} -1 带符号保留小数点后两位 2.71828 {:.0f} 3 不带小数 1000000 {:,} 1,000,000 以逗号分隔的数字格式 0.25 {:.2%} 25.00% 百分比格式 1000000000 {:.2e} 1.00E+09 指数记法 25 {0:b} 11001 转换成二进制 25 {0:d} 25 转换成十进制 25 {0:o} 31 转换成八进制 25 {0:x} 19 转换成十六进制 5 {:0&gt;2} 05 数字补零(填充左边, 宽度为2) 5 {:x&lt;4} 5xxx 数字补x (填充右边, 宽度为4) 10 {:x^4} x10x 数字补x (填充两边,优先左边, 宽度为4) 13 {:10} 13 右对齐 (默认, 宽度为10) 13 {:&lt;10} 13 左对齐 (宽度为10) 13 {:^10} 13 中间对齐 (宽度为10)]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>format</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python的*args和**kwargs]]></title>
    <url>%2F2018%2F09%2F02%2FPython%E7%9A%84args%E5%92%8C-kwargs%2F</url>
    <content type="text"><![CDATA[使用场景 *args是用来接收一个(非键值对)不定长度的参数列表给一个函数 **kwargs允许你将不定长度的键值对，作为参数传递给一个函数。 *args: 位置参数*args：将参数组织成元组:123456def test_para(*args): print(args)&gt;&gt;&gt;test_para('code')('code',)&gt;&gt;&gt;test_para(1,2,3)(1,2,3) 与普通参数的组合使用123456def test_para(ar1,*args): print(ar1) print(args)&gt;&gt;&gt;print_para('hello',1,2,3)hello(1,2,3) **kw：关键字参数将参数组织成字典数据类型12345678def test_para(x,y,z=3,*args,**kw): print(x,y,z) print(args) print(kw) &gt;&gt;&gt;test_para(1,2,4,5,6,7,foo=1,bar=2)1 2 4(5,6,7)&#123;'foo':1,'bar':2&#125; 还可以使用这种方式创建字典 12def create_dict(**kw): return kw]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python的命名规范]]></title>
    <url>%2F2018%2F08%2F28%2FPython%E7%9A%84%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[文件名全小写，可使用下划线 包名、模块名全部小写字母 类名单词首字母大写，如MyClass 函数&amp;方法函数名应该为小写，可以用下划线风格单词以增加可读性。 变量名变量名全部小写，由下划线连接各个单词。 常量常量名所有的字母大写，由下划线连接各个单词MAX_OVERFLOW、TOTAL]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进程与线程基础]]></title>
    <url>%2F2018%2F08%2F28%2F%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[进程与线程的区别进程在操作系统上表现为一个程序的动态执行过程，进程是系统进行资源分配的调度的基本单位。线程是进程的一个实体，是CPU调度和分配的基本单位。线程自己基本上是不拥有系统资源，只拥有一点并不可少的资源（如程序计数器，一组寄存器和栈），但是他可与同属一个进程的其它线程共享所拥有全部资源。 进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。 进程引入的意义为使程序能够并发执行，且为了对并发执行的程序加以描述和控制，人们引入了”进程”概念。 线程的同步和通信 互斥锁(mutex) 互斥锁是一种简单的，用于实现线程间对资源互斥访问的机制。由于操作互斥锁的时间和空间开销都较低，因而较合适于高频度使用关键字共享数据的程序段。互斥锁可以有两种状态，即开锁和关锁状态。相应的，可以用两条命令对互斥锁进行操作。其中关锁lock操作用于将mutex关上，开锁操作unlock则用于打开mutex. 条件变量 在许多情况下，只利用mutex来实现互斥访问可能会引起死锁，我们通过一个例子来说明这一点。有一个线程在对mutex1执行关锁操作成功后，便进入一临界区C，若在临界区内该线程又须访问某个临界资源R，同样也为R设置另一个互斥锁mutex2.假如资源R此时正处于忙碌状态，线程在对mutex2执行关锁操作后必将被阻塞，这样将使mutex1一直保持关锁状态；如果保持了R的线程也要求进入临界区C，但由于mutex1一直保持关锁状态而无法进入临界区，这样便形成了死锁。为解决这个问题变引入了条件变量。 每一个条件变量通常都与一个互斥锁一起使用，亦即，在创建一个互斥锁时便联系着一个条件变量。单纯的互斥锁用于短期锁定，主要是用来保证对临界区的互斥进入。而条件变量则用于线程的长期等待，直至所等待的资源成为可用的资源。 现在，我们可以看看如何利用互斥锁和条件变量来实现对资源R的访问。线程首先对mutex执行关锁操作，若成功便进入临界区，然后查找用于描述该资源状态的数据结构，以了解资源的情况。只要发现所需资源R正处于忙碌状态，线程便转为等待状态，并对mutex执行开锁操作后，等待该资源被释放；若资源处于空闲状态，表明线程可以使用该资源，于是将该资源设置为忙碌状态，再对mutex执行开锁操作。 信号量机制 前面介绍的用于实现进程同步的最常用工具–信号量机制，也可用于多线程OS中，实现诸线程或进程之间的同步。 私用信号量 当某线程需利用信号量来实现同一进程中各线程之间的同步时，可调用创建信号量的 命令来创建一私用信号量，其数据结构存放在应用程序的地址空间中。私用信号量属于特 定的进程所有，OS 并不知道私用信号量的存在，因此，一旦发生私用信号量的占用者异常 结束或正常结束，但并未释放该信号量所占有空间的情况时，系统将无法使它恢复为 0(空)， 也不能将它传送给下一个请求它的线程。 共用信号量 公用信号量是为实现不同进程间或不同进程中各线程之间的同步而设置的。由于它有 着一个公开的名字供所有的进程使用，故而把它称为公用信号量。其数据结构是存放在受 保护的系统存储区中，由 OS 为它分配空间并进行管理，故也称为系统信号量。如果信号量 的占有者在结束时未释放该公用信号量，则 OS 会自动将该信号量空间回收，并通知下一进程。可见，共用信号量是一种比较安全的同步机制。]]></content>
      <categories>
        <category>Operating System</category>
      </categories>
      <tags>
        <tag>进程与线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[脑控飞行器之MATLAB部分]]></title>
    <url>%2F2018%2F08%2F27%2F%E8%84%91%E6%8E%A7%E9%A3%9E%E8%A1%8C%E5%99%A8%E4%B9%8BMATLAB%E9%83%A8%E5%88%86%2F</url>
    <content type="text"><![CDATA[Create TCP/IP objecttcp_Server = tcpip(&#39;192.168.1.151&#39;,8123,&#39;NetWorkRole&#39;,&#39;Server&#39;) 解释： 该命令是创建一个tcpip的对象tcp_Server,这个对象连接的远程主机的ip是192.168.1.151，远程主机的port是8123，该对象的网络角色是服务端。]]></content>
      <tags>
        <tag>MATLAB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础1]]></title>
    <url>%2F2018%2F08%2F27%2FJava%E5%9F%BA%E7%A1%801%2F</url>
    <content type="text"><![CDATA[面向对象的三个特征封装、继承、多态，有时加上抽象 创建对象的几种方式 采用new 通过反射 采用clone 通过序列化机制 一个java文件内部可以有类吗？只能有一个public公共类，并且public的类名必须与文件名相一致，但是可以有多个default修饰的类。 String 是基本数据类型吗不是。在Java中内建了8种数据类型来存储整数、浮点数、字符和布尔值。数据类型分类如下： 基本数据类型 整形：long、int、short、byte 浮点型：float、double 布尔型：boolean 字符型：char 引用数据类型 数组 接口 类 构造器是否能够被重写构造器不能够被继承，因此不能被重写，但可以被重载 参数静态变量和实例变量的区别静态变量是被static修饰符修饰的变量，也称为类变量，它属于类，不属于类中的任何一个对象，一个类不管创建多少个对象，静态变量在内存中有且仅有一个拷贝；实例变量必须依存于某一个实例，需要先创建对象然后通过对象才能访问到它。静态变量可以实现让多个对象共享内存。 是否可以从一个静态方法内部发出对非静态方法的调用不可以，静态方法只能是访问静态成员，因为非静态方法发的调用要先创建对象，在调用静态方法时可能对象对没有被初始化 Java中的final关键字有哪些用法final关键字的中文含义是“最终“，可以修饰常量、方法和类。 修饰类，表示该类不能够被继承 修饰方法，表示方法不能被重写 修饰变量，表示变量只能一次赋值后不能够被修改(常量)，引用变量的值还是可以修改的 &amp;和&amp;&amp;的区别&amp;运算符有两种用法: 按位与 逻辑与 &amp;&amp;是短路与运算符。逻辑与和短路与的差别是很大的，虽然二者都要求运算符左右两端的布尔值都是true整个表达式才是true。&amp;&amp;之所以称为短路运算时因为，如果&amp;&amp;左边的表达式值是false，右边的表达式会被直接短路掉，不会进行运算。 String类是否可以继承String类时final类，不可以被继承 静态变量与实例变量的区别 在语法定义上的区别: 静态变量前要加static关键字，而实例变量是不需要加的 在程序运行时的区别，实例变量属于某个对象的属性，必须创建了实例对象，其中的示例变量才会被分配空间，才能使用这个实例变量。静态变量不属于某个实例对象，而是属于类。所以也称为类变量，只要是程序加载了类的字节码，不用创建任何实例对象，静态变量就会被分配空间，静态变量就可以被使用了 总之，实例变量必须创建对象后才可以通过这个对象使用，静态变量则可以通过类名直接使用。 对于实例变量，每创建一个实例，JVM就会为实例变量分配一次内存，实例变量可以在内存中有多个备份，互不影响。实例变量隶属于对象。在类的内部，非静态方法可以直接访问实例变量。本类中的静态方法或其他类，则需要本类的实例变量访问实例变量 对于静态变量，加载类的过程中完成静态变量的内存分配，JVM只为静态变量分配一次内存，而且静态变量在内存中只有一个备份。静态变量可以被所有的对象之间共享。在本类中，任何方法都可以直接访问静态变量，当然也可以通过对象来访问（不推荐）。在其他类中，则需要类名来访问静态变量。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java的继承与多态]]></title>
    <url>%2F2018%2F08%2F26%2FJava%E7%9A%84%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81%2F</url>
    <content type="text"><![CDATA[访问修饰符访问修饰符的作用访问修饰符是用来控制类、属性、方法的可见性的关键字 作用范围 修饰符 类内部 同一个包 子类 任何地方 private Yes default Yes Yes protected Yes Yes Yes public Yes Yes Yes Yes 注：对于class的权限修饰只可以用public和default public类可以在任意地方被访问 default类只可以被同一个包内的类访问 重写与重载定义重载在同一个类中实现两个或两个以上的方法名相同而参数列表不相同的方法。 重写重写指的是在Java的子类中定义的方法使用的方法名、返回类型和参数列表与父类中的方法一样、则称子类的方法重写了父类中的方法。 方法的重写只存在与子类和父类之间，而同一个类中只能重载。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git基础2]]></title>
    <url>%2F2018%2F08%2F26%2FGit%E5%9F%BA%E7%A1%802%2F</url>
    <content type="text"><![CDATA[何为GitGit是一个开源的分布式版本控制系统，作用就是对文件进行版本管理，方便在不同的版本之间切换修改。 创建仓库git initGit使用git init命令来初始化一个Git仓库，Git的很多命令都是在Git仓库中运行的。 使用当前目录作为Git仓库，我们只需要使它初始化。 git init 该命令执行完毕后会在当前目录生成一个.git目录 使用我们指定目录作为Git仓库 git init newrepo 初始化后，会在newrepo目录下出现一个.git的目录，所有Git需要的数据和资源都存放在这个目录中。 git clone我们使用git clone从现有Git仓库中拷贝项目 git clone &lt;repo&gt; 如果我们需要拷贝到指定目录下，可以使用以下命令格式： git clone &lt;repo&gt; &lt;directory&gt; 该命令使用后，会使用指定的目录替代远程仓库上的目录 增加/删除文件git add我们可以添加文件到暂存区，使用如下命令： git add &lt;filename&gt; 或者 git add * 123456789#添加指定文件到暂存区$ git add [file1] [file2] ...#添加指定目录到暂存区，包括子目录$ git add [dir]#添加当前所有文件到暂存区$ git add *# 添加每个变化前，都会要求确认# 对于同一个文件的多处变化，可以实现分次提交$ git add -p git rm git rm file_path 删除暂存区或者分支上的文件，同时工作区也不需要这个文件了 git rm --cached &lt;filename&gt; 删除暂存区或分支上的文件, 但该文件会保留在工作区 代码提交git commit使用git add命令将想要的快照的内容写入缓存区，而执行git commit将缓存区的内容添加到仓库中 使用如下命令实际提交改动： git commit -m &quot;代码提交信息&quot; 例如： 1234567891011 #提交暂存区到仓库区$ git commt -m [message] #提交暂存区的指定文件到仓库区$ git commit [file1] [file2] ... -m [message] #提交工作区自上次commit之后的变化，直接到仓库区$ git commmit -a #提交时显示所有的diff信息$ git commit -v #使用一次新的commit,替代上一次提交#如果代码没有任何变化，则用来改写上一次commit的提交信息$ git commit -amend -m [message] 分支123456789101112131415161718192021222324252627282930313233343536373839404142#列出本地所有的分支$ git branch#列出所有的远程分支$ git branch -r# 列出所有的本地分支和远程分支$ git branch -a# 新建一个分支，但依然停留在当前分支$ git branch [branch-name]# 新建一个分支，并切换到该分支$ git checkout -b [branch]# 新建一个分支，指向指定commit$ git branch [branch] [commit]# 新建一个分支，与指定的远程分支建立追踪关系$ git branch --track [branch] [remote-branch]# 切换到指定分支，并更新工作区$ git checkout [branch-name]# 切换到上一个分支$ git checkout -# 建立追踪关系，在现有分支与指定的远程分支之间$ git branch --set-upstream [branch] [remote-branch]# 合并指定分支到当前分支$ git merge [branch]# 选择一个commit，合并进当前分支$ git cherry-pick [commit]# 删除分支$ git branch -d [branch-name]# 删除远程分支$ git push origin --delete [branch-name]$ git branch -dr [remote/branch] 查看信息git statusgit status查看的是工作区和暂存区的状态 1234$ git statusOn branch master #表示现在在master默认分支上No commits yet #本地库没有被提交过东西nothing to commit(create/copy) files and use "git add" to track #暂存区什么也没有 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960# 显示有变更的文件$ git status# 显示当前分支的版本历史$ git log# 显示commit历史，以及每次commit发生变更的文件$ git log --stat# 搜索提交历史，根据关键词$ git log -S [keyword]# 显示某个commit之后的所有变动，每个commit占据一行$ git log [tag] HEAD --pretty=format:%s# 显示某个commit之后的所有变动，其"提交说明"必须符合搜索条件$ git log [tag] HEAD --grep feature# 显示某个文件的版本历史，包括文件改名$ git log --follow [file]$ git whatchanged [file]# 显示指定文件相关的每一次diff$ git log -p [file]# 显示过去5次提交$ git log -5 --pretty --oneline# 显示所有提交过的用户，按提交次数排序$ git shortlog -sn# 显示指定文件是什么人在什么时间修改过$ git blame [file]# 显示暂存区和工作区的差异$ git diff# 显示暂存区和上一个commit的差异$ git diff --cached [file]# 显示工作区与当前分支最新commit之间的差异$ git diff HEAD# 显示两次提交之间的差异$ git diff [first-branch]...[second-branch]# 显示今天你写了多少行代码$ git diff --shortstat "@&#123;0 day ago&#125;"# 显示某次提交的元数据和内容变化$ git show [commit]# 显示某次提交发生变化的文件$ git show --name-only [commit]# 显示某次提交时，某个文件的内容$ git show [commit]:[filename]# 显示当前分支的最近几次提交$ git reflog 远程同步git push现在，相关改动已经提交到了HEAD，但是还没有到你的远端仓库。执行如下命令以将这些改动提交到远端仓库： git push origin master 其中origin为远程主机名，master本地分支 git fetch一旦远程主机的版本有了更新，需要将这些更新取回本地，这时就需要用到git fetch命令 1$ git fetch &lt;远程主机名&gt; 上面的命令将某个远程主机的更新，全部取回本地 git fetch命令通常来查看他人的进程，因为它取回的代码对你本地的开发代码没有影响。 默认情况下， git fetch取回所有分支的更新。如果只想取回特定分支的更新，可以指定分支名。 1$ git fetch &lt;远程主机名&gt; &lt;分支名&gt; 比如，取回origin主机的master分支 1$ git fetch origin master 所取回的更新，在本地主机上要用”远程主机名/分支名”的形式读取。比如origin主机的master，就要用origin/master读取。 git pullgit pull命令的作用是，取回远程主机某个分支的更新，再与本地的指定分支合并。它的完整格式稍稍有点复杂。 1$ git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt; 比如，取回origin主机的next分支，与本地的master分支合并，需要写成下面这样。 1$ git pull origin next:master 如果远程分支是与当前分支合并，则冒号后面的部分可以省略。 1$ git pull origin next 上面命令表示，取回origin/next分支，再与当前分支合并。实质上，这等同于先做git fetch，再做git merge 12$ git fetch origin$ git merge origin/next 1234567891011121314151617181920212223# 下载远程仓库的所有变动$ git fetch [remote]# 显示所有远程仓库$ git remote -v# 显示某个远程仓库的信息$ git remote show [remote]# 增加一个新的远程仓库，并命名$ git remote add [shortname] [url]# 取回远程仓库的变化，并与本地分支合并$ git pull [remote] [branch]# 上传本地指定分支到远程仓库$ git push [remote] [branch]# 强行推送当前分支到远程仓库，即使有冲突$ git push [remote] --force# 推送所有分支到远程仓库$ git push [remote] --all]]></content>
      <categories>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Git基础1]]></title>
    <url>%2F2018%2F08%2F21%2FGit%E5%9F%BA%E7%A1%801%2F</url>
    <content type="text"><![CDATA[Git的几个区 工作区 新建文件，修改文件的地方 暂存区 零时存储的地方 本地库 存储历史版本 几个专用名词 Workspace:：工作区 Index：暂存区 Repository：本地仓库 Remote：远程仓库 设置签名 形式 username Email 作用 区分不同开发提交人员的身份 辨析 这里设置的签名和登录远程库（代码托管中心）的账号、密码没有恩和关系 命令 项目级别/仓库级别：仅在当前本地库范围内有效 git config user.name Tom git config user.email helloworld@qi.com 信息保存位置在项目中.git/config文件中 系统用户级别：登录当前操作系统用户的范围 git config –global user.name Tom git config –global user.email helloworld@qi.com 信息保存在~/.gitconfig中 如何二者都有设置，那么就近原则，项目级别的生效，不存在二者都不存在的情况]]></content>
      <categories>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[odoo]]></title>
    <url>%2F2018%2F08%2F21%2Fodoo%2F</url>
    <content type="text"><![CDATA[What’s the Odoo?Odoo是一个开源框架，针对ERP的需求发展而来的，适合定制出客户各种需求的ERP系统和单电子商务系统。 它 是一系列开源商业应用程序套装，此套装可满足贵公司的一切应用需求，例如，企业基本的进销存、采购、销售、MRP生产制造、品保质量保障、企业招聘、员工合同、休假、午餐管理、内部论坛、车队管理、内部聊天IM沟通、客诉追溯管理、CRM客户关系管理、VOIP、E-Shop电子商务、网店、企业官方网站，财务会计、银行对账、资产管理、HR工资管理、预算管理、WMS仓库库存管理、POS街边小摊、社区商店、项目管理、条码、PLM等等等。 简单地说，Odoo 是一个快速开发 ERP 应用的 Web 框架，同时附带了很多基础模块可以直接使用和进行二次开发，它最大的特点是开源和模块化。开源意味着我们可以免费、自由地（在遵守开源协议的前提下）获取到相关的资源，也意味着有强大的社区支持和应用生态可以解决我们开发中所遇到的各种问题。而模块化则是 Odoo 区别于大多数传统 ERP 的最强特性，基于这一特性，开发人员可以轻松地继承和扩展任何现有的模块，可以轻松地针对不同的需求进行功能定制。 ModelsWhat’s a Model in odoo? In Odoo, model is a class that maps to the data relation (table) and potentially bridge tables (e.g. for many to many relations). It contains the essential fields and behaviors of the data you’re storing. Generally, each model maps to a single database table. The same class can have methods for the manipulations on the corresponding data. Basic Points about odoo Model: Each model is a Python class that subclasses openerp.models.Model. Each attribute of the model represents a database field. Models describe business objects, such as an opportunity, sales order, or partner (customer, supplier, and so on). A model has a list of attributes and can also define its specific business. Models are implemented using a Python class derived from an Odoo template class. They translate directly to database objects, and Odoo automatically takes care of this when installing or upgrading the module. The mechanism responsible for this is the Object Relational Model (ORM). viewsThe view layer describes the user interface. Views are defined using XML, which is used by the web client framework to generate data-aware HTML views. SecurityOdoo权限的核心是权限组(res_groups).对每个权限组，可以设置权限组的菜单表示，对象表示，记录规则表示，字段表示。 菜单、对象表示 设置哪些人可以访问哪些菜单/对象，对象的访问权限包括创建、读、写、删除 记录级别 设置哪些人可以访问哪些记录，也就是表的查询权限 字段级别 设置表中字段的访问权限 工作流级别 在工作流的每一步迁移中，设置哪些角色允许触发迁移]]></content>
      <categories>
        <category>Project</category>
      </categories>
      <tags>
        <tag>odoo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法综合]]></title>
    <url>%2F2018%2F08%2F21%2F%E7%AE%97%E6%B3%95%E7%BB%BC%E5%90%88%2F</url>
    <content type="text"><![CDATA[二分搜索算法二分搜索，也称为折半搜索、对数搜索，是一种在有序数组中查找某一特定元素的搜索算法。搜索过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。这种搜索算法每一次比较都使搜索范围缩小一半。 123456789101112131415161718def binary_search(num,li): low = 0 high = len(li)-1 while low &lt;= high: mid = (low+high)//2 if li[mid] &lt; num: low = mid + 1 elif li[mid] &gt; num: high = mid - 1 else: return mid return -1if __name__ == "__main__": b = [1,2,5,8,11,13] print(b) a = binary_search(56,b) print(a) 跳台阶问题普通跳台阶 首先我们考虑最简单的情况。如果只有1级台阶，那显然只有一种跳法。如果有2级台阶，那就有两种跳的方法了：一种是分两次跳，每次跳1级；另外一种就是一次跳2级。 现在我们再来讨论一般情况。我们把n级台阶时的跳法看成是n的函数，记为f(n)。当n&gt;2时，第一次跳的时候就有两种不同的选择：一是第一次只跳1级，此时跳法数目等于后面剩下的n-1级台阶的跳法数目，即为f(n-1)；另外一种选择是第一次跳2级，此时跳法数目等于后面剩下的n-2级台阶的跳法数目，即为f(n-2)。因此n级台阶时的不同跳法的总数f(n)=f(n-1)+(f-2)。 我们把上面的分析用一个公式总结如下： / 1 n=1 f(n)= 2 n=2​ \ f(n-1)+(f-2) n&gt;2 123456789class Solution(object): def jumpFloor(self,number): fn1 = 1 fn2 = 2 while number &gt;1: fn2 = fn1 + fn2 fn1 = fn2 - fn1 number -= 1 return fn1 变态跳台阶 变态跳台阶问题是这样的：如果青蛙可以一次跳 1 级，也可以一次跳 2 级，一次跳 3 级，…，一次跳 nn 级。问要跳上第 n 级台阶有多少种跳法？ 同样的，我们采用逆向思维，将问题改为：跳上第 nn 级台阶该怎么跳？答案如下： 要跳上第 nn 级台阶，可以从第 n−1级台阶一次跳上来，也可以可以从第 n−2级台阶一次跳上来，也可以可以从第 n−3级台阶一次跳上来，…，也可以可以从第 1 级台阶一次跳上来。那么问题就很简单啦，同样的，令 f(n) 表示从第一级台阶跳上第 nn 级台阶有几种跳法。则有如下递推公式：$$f(n)=f(n-1)+f(n-2)+…+f(1)$$同时，f(n-1)也可以表示如下:$$f(n-1) = f(n-2)+f(n-3)+…f(1)$$所以，由上面两个公式可知：$$f(n)=2f(n-1)=4f(n-2)=8f(n-3)=…$$即：$$f(n)=2f(n-1)=2^2f(n-2)=2^3f(n-3)=…=2^{n-1}f(n-(n-1))=2^{n-1}f(1)$$因为f(1)=1,所以$$f(n)=2^{n-1}$$ 123import mathdef jumpFloor(n): return math.pow(2,n-1) ### 猴子吃桃问题有一群猴子，去摘了一堆桃子 ，商量之后决定每天吃剩余桃子的一半 ，当每天大家吃完桃子之后，有个贪心的小猴都会偷偷再吃一个桃子 ，按照这样的方式猴子们每天都快乐的吃着桃子 ，直到第十天，当大家再想吃桃子时，发现只剩下一个桃子了 ，问：猴子们一共摘了多少桃子 分析: 今天的桃子 = 昨天的桃子 - （昨天的桃子/2 + 1），即$$Now = Yester - (Yester \div 2 + 1 )Yester = 2*(Now + 1)$$ 123456789def solution(): # 第十天的桃子 total = 1 for i in range(9,0,-1): total = (total + 1)*2 return totalif __name__ == '__main__': print solution() 闰年的判断四年一闰，百年不闰，四百年再闰 12345678def solution(year): if ( year%4 == 0 and year%100 != 0) or (year % 400 == 0): return True else: return Falseif __name__ == '__main__': print(solution()) 连续子数组的最大和HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。你会不会被他忽悠住？ 解析： 两个变量，一个变量tempsum来记录一段一段的和，只要tempsum&gt;0，它就可以继续往下加，因为无论array[i]大于0还是小于0，只要加上一个比0大的数，都比自己原来更大，但是如果tempsum&lt;0，就另起一个头，以array[i]为头，它不被之前的tempsum影响，有了一个新的tempsum 每次求出新的tempsum都和sum比较一下，如果当前的tempsum&gt;sum，则替换掉原来的，否则维持sum不变 1234567891011121314151617def findMax(alist): if len(alist) == 0: return 0 tempSum = alist[0] sum = alist[0] for i in range(1, len(alist)): if tempSum &gt; 0: tempSum += alist[i] else: tempSum = alist[i] if tempSum &gt; sum: sum = tempSum return suma = [6, -3, -2, 7, -15, 1, 2, 2]print(findMax(a))]]></content>
      <categories>
        <category>Data Structures and Algorithms</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树总结]]></title>
    <url>%2F2018%2F08%2F21%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E6%A0%91%2F</url>
    <content type="text"><![CDATA[树的概念是一种抽象数据类型或是视作这种抽象数据类型的数据结构，用来模拟具有树状结构性质的数据集合。它是由n个有限结点组成一个具有层次关系的集合。 每个结点有零个或多个子结点 没有父节点的结点称为根结点 每一个非根结点有且只有一个父节点 除了根结点外，每个子结点可以分为多个不相交的子树 树其实就是不包含贿赂的连无向图。 树的术语注：我们在对一颗树进行讨论的时候，树的节点或者结点是可以相互使用的，意义一样 节点的度：一个节点含有子树的个数称为该节点的度 树的度：一颗树中，最大结点的度称为树的度 叶节点：度为零的节点 父节点：若一个节点含有子节点，则这个节点称为其子节点的父节点 孩子节点或子节点：一个节点含有的子树的根结点称为该节点的子节点 兄弟节点：具有相同父节点的子节点称为兄弟节点 节点的层次：从根开始定义起，根为第一层，根的子节点为第二层，以此类推 树的高度或者深度：树中节点的最大层次 二叉树基本概念二叉树是每个节点最多有两个子树的树结构。通常子树被称作“左子树”和“右子树” 二叉树的性质 在二叉树的第i层上至多有2^(i-1)个节点 深度为k的二叉树至多有2^k-1个节点 二叉树的分类满二叉树一颗深度为k且有2^k-1个结点的二叉树称为满二叉树。如图 完全二叉树若设二叉树的深度为h,除第h层外，其它各层(1~h-1)的结点数都达到最大个数，第h层所有的结点都连续集中在最左边，这就是完全二叉树。如图： 二叉查找树（BST）简介二叉查找树(Binary Search Tree)，也称为二叉搜索树、有序二叉树或排序二叉树，是一种特殊的二叉树，它改善了二叉树节点的查找效率。 性质 其左子树下的每个后代节点的值都小于节点n的值 其右子树下的每个后代节点的值都大于节点n的值 任意节点的左右子树也也分别为二叉查找树 没有键值相等的节点 总结来说，我们使用的查找算法过程如下： 假设我们要查找节点 n，从 BST 的根节点开始。算法不断地比较节点值的大小直到找到该节点，或者判定不存在。每一步我们都要处理两个节点：树中的一个节点，称为节点 c，和要查找的节点 n，然后并比较 c 和 n 的值。开始时，节点 c 为 BST 的根节点。然后执行以下步骤： 如果 c 值为空，则 n 不在 BST 中； 比较 c 和 n 的值； 如果值相同，则找到了指定节点 n； 如果 n 的值小于 c，那么如果 n 存在，必然在 c 的左子树中。回到第 1 步，将 c 的左孩子作为 c； 如果 n 的值大于 c，那么如果 n 存在，必然在 c 的右子树中。回到第 1 步，将 c 的右孩子作为 c； 通过BST查找节点，理想情况下我们需要检查的节点数可以减半。如下图的BST树，包含了15个节点，从根节点开始执行查找算法，第一次比较决定我们是移向左子树还是移向右子树。对于任意一种情况，一旦执行这一步，我们需要访问的节点数就减少了一般，从15到7。同样，下一步的访问的节点也减少了一半，从7降到3，依此类推。 根据这一特点，查找算法的时间复杂度应该是 O(log­2n)，简写为 O(lg n)。我们在文章《算法复杂度分析》中有一些关于时间复杂度的描述。可知，log­2n = y，相当于 2y = n。即，如果节点数量增加 n，查找时间只缓慢地增加到 log­2n。下图中显示了 O(log­2n) 和线性增长 O(n) 的增长率之间的区别。时间复杂度为 O(log­2n) 的算法运行时间为下面那条线。 从上图可以看出，O(log­2n) 曲线几乎是水平的，随着 n 值的增加，曲线增长十分缓慢。举例来说，查找一个具有 1000 个元素的数组，需要查询 1000 个元素，而查找一个具有 1000 个元素的 BST 树，仅需查询不到10 个节点（log21024 = 10）。 而实际上，对于 BST 查找算法来说，其十分依赖于树中节点的拓扑结构，也就是节点间的布局关系。下图描绘了一个节点插入顺序为 20, 50, 90, 150, 175, 200 的 BST 树。这些节点是按照递升顺序被插入的，结果就是这棵树没有广度（Breadth）可言。也就是说，它的拓扑结构其实就是将节点排布在一条线上，而不是以扇形结构散开，所以查找时间也为 O(n)。 当 BST 树中的节点以扇形结构散开时，对它的插入、删除和查找操作最优的情况下可以达到亚线性的运行时间 O(log2n)。因为当在 BST 中查找一个节点时，每一步比较操作后都会将节点的数量减少一半。尽管如此，如果拓扑结构像上图中的样子时，运行时间就会退减到线性时间 O(n)。因为每一步比较操作后还是需要逐个比较其余的节点。也就是说，在这种情况下，在 BST 中查找节点与在数组（Array）中查找就基本类似了。 因此，BST 算法查找时间依赖于树的拓扑结构。最佳情况是 O(log­2n)，而最坏情况是 O(n)。 插入节点当向树中插入一个新节点时，该节点将总是作为叶子节点。所以，最困难的地方在于如何找到该节点的父节点。类似于查找算法中的描述，我们将这个新的节点称为节点n，而遍历的当前节点称为节点c。开始时，节点c为BST的根节点。则定为n节点的父节点步骤如下： 如果节点 c 为空，则节点 c 的父节点将作为节点 n 的父节点。如果节点 n 的值小于该父节点的值，则节点 n 将作为该父节点的左孩子；否则节点 n 将作为该父节点的右孩子。 比较节点 c 与节点 n 的值。 如果节点 c 的值与节点 n 的值相等，则说明用户在试图插入一个重复的节点。解决办法可以是直接丢弃节点 n，或者可以抛出异常。 如果节点 n 的值小于节点 c 的值，则说明节点 n 一定是在节点 c 的左子树中。则将父节点设置为节点 c，并将节点 c 设置为节点 c 的左孩子，然后返回至第 1 步。 如果节点 n 的值大于节点 c 的值，则说明节点 n 一定是在节点 c 的右子树中。则将父节点设置为节点 c，并将节点 c 设置为节点 c 的右孩子，然后返回至第 1 步。 当合适的节点找到时，该算法结束。从而使新节点被放入 BST 中成为某一父节点合适的孩子节点。 BST 的插入算法的复杂度与查找算法的复杂度是一样的：最佳情况是 O(log­2n)，而最坏情况是 O(n)。因为它们对节点的查找定位策略是相同的。 插入节点从 BST 中删除节点比插入节点难度更大。因为删除一个非叶子节点，就必须选择其他节点来填补因删除节点所造成的树的断裂。如果不选择节点来填补这个断裂，那么就违背了 BST 的性质要求。 删除节点算法的第一步是定位要被删除的节点，这可以使用前面介绍的查找算法，因此运行时间为 O(log­2n)。接着应该选择合适的节点来代替删除节点的位置，它共有三种情况需要考虑。 情况 1：如果删除的节点没有右孩子，那么就选择它的左孩子来代替原来的节点。二叉查找树的性质保证了被删除节点的左子树必然符合二叉查找树的性质。因此左子树的值要么都大于，要么都小于被删除节点的父节点的值，这取决于被删除节点是左孩子还是右孩子。因此用被删除节点的左子树来替代被删除节点，是完全符合二叉搜索树的性质的。 情况 2：如果被删除节点的右孩子没有左孩子，那么这个右孩子被用来替换被删除节点。因为被删除节点的右孩子都大于被删除节点左子树的所有节点，同时也大于或小于被删除节点的父节点，这同样取决于被删除节点是左孩子还是右孩子。因此，用右孩子来替换被删除节点，符合二叉查找树的性质。 情况 3：如果被删除节点的右孩子有左孩子，就需要用被删除节点右孩子的左子树中的最下面的节点来替换它，就是说，我们用被删除节点的右子树中最小值的节点来替换。 我们知道，在 BST 中，最小值的节点总是在最左边，最大值的节点总是在最右边。因此替换被删除节点右子树中最小的一个节点，就保证了该节点一定大于被删除节点左子树的所有节点。同时，也保证它替代了被删除节点的位置后，它的右子树的所有节点值都大于它。因此这种选择策略符合二叉查找树的性质。 和查找、插入算法类似，删除算法的运行时间也与 BST 的拓扑结构有关，最佳情况是 O(log­2n)，而最坏情况是 O(n)。 平衡二叉树概念平衡二叉树(Balanced Binary Tree)又被称为AVL数，且具有以下性质：它是一颗空树或者它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一颗平衡二叉树。 常用的算法为：红黑树、AVL树、Treap树 应用场景二叉树支持动态的插入和查找，保证操作在O(height)时间，这就是完成了哈希表不便完成的工作，动态性。但是二叉树有可能出现worst-case，如果输入序列已经排序，则时间复杂度为O(N) 平衡二叉树/红黑树就是为了将查找的时间复杂度保证在O(logN)范围内。 所以如果输入集合确定，所需要的就是查询，则可以考虑使用哈希表，如果输入集合不确定，则考虑使用平衡二叉树/红黑树，保证达到最大效率 平衡二叉树主要优点集中在快速查找。 红黑树介绍R_B Tree，全称是Red-black Tree,又称为“红黑树”，它是一种自平衡的二叉查找树。但它在二叉树的基础上添加了着色和相关的性质使得红黑树相对平衡，从而保证红黑树的查找、插入、删除的时间复杂度最坏为O(lgn)。 性质红黑树，除了满足二叉查找树的一般性质，还具有以下5个性质 每个节点都是红色或者黑色 根结点是黑色 每个叶子节点是黑色 如果一个节点是红色的，则它的子节点必须是黑色的 从任一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。 红黑树的应用我们知道，二叉查找树在大多数情况下查找和插入在效率上是没有问题的，但是在最坏的情况下效率比较低，但是平衡二叉树能偶在最坏的情况下也能够达到lgN，要实现这一目标，就要保证在插入完成后始终保持平衡状态。在一棵具有N个节点的树中，我们希望该树的高度能够维持在lgN左右，这样我们就能保证只需要lgN次比较操作就可以查找到想要的值。不幸的是，每次插入元素之后维持树的平衡状态太昂贵。所以就出现一些新的数据结构来保证在最坏的情况下插入和查找效率都能保证在对数的时间复杂度内完成。而我们所讲的红黑树就属于此新的数据结构之一，除此之外还有B树等数据结构。 B树B+树树的实现二叉树的深度输入一颗二叉树，求该树的深度。从根结点到叶节点依次经过的结点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度 12345class TreeNode(object): def __init__(self,x): self.val = x self.left = None self.right = None 解法一1234567891011121314151617class Solution(object): def TreeDepth(self,pRoot): if not pRoot: return 0 A = [] depth = 0 A.append(pRoot) while A: temp = [] for node in A: if node.left: temp.append(node.left) if node.right: temp.append(node.right) A = temp depth += 1 return depth 解法二注：此题思路想不通 12345class Solution(object): def TreeDepth(self,pRoot): if not pRoot: return 0 return max(self.TreeDepth(pRoot.left),self.TreeDepth(pRoot.right))+1 二叉树的遍历二叉树的创建及遍历123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384# -*- coding:utf-8 -*-class Node(object): """节点的创建""" def __init__(self,val=None): self.val =val self.lchild = None self.rchild = Noneclass BinaryTree(object): def __init__(self): self.root = None def is_empty(self): """判空""" return self.root == None def add(self,val): """添加节点""" node = Node(val) if self.root == None: self.root = node return queue = [self.root] while queue: cur = queue.pop(0) if cur.lchild == None: cur.lchild = node return else: queue.append(cur.lchild) if cur.rchild == None: cur.rchild = node return else: queue.append(cur.rchild) def breadth_travel(self): """广度优先遍历""" if self.root == None: return queue = [self.root] while queue: cur = queue.pop(0) print(cur.val,end=' ') if cur.lchild: queue.append(cur.lchild) if cur.rchild: queue.append(cur.rchild) print() def preorder(self,node): """先序遍历""" if node == None: return print(node.val,end=' ') self.preorder(node.lchild) self.preorder(node.rchild) def inorder(self,node): """中序遍历""" if node == None: return self.inorder(node.lchild) print(node.val,end=' ') self.inorder(node.rchild) def postorder(self,node): """后序遍历""" if node == None: return self.postorder(node.lchild) self.postorder(node.rchild) print(node.val,end=' ')if __name__ == '__main__': t = BinaryTree() print(t.is_empty()) t.add(1) t.add(2) t.add(3) t.breadth_travel() t.preorder(t.root) t.inorder(t.root) t.postorder(t.root) 二叉树的重建12 二叉排序树代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596class TreeNode(object): def __init__(self,key,value,parent=None,left=None,right=None): self.key = key self.value = value self.leftChild = left self.rightChild = right self.parent = parent def hasLeftChild(self): return self.leftChild def hasRightChild(self): return self.rightChild def isLeftChild(self): return self.parent and self.leftChild == self def isRightChild(self): return self.parent and self.rightChild == self def isRoot(self): return not self.parent def isLeaf(self): return not (self.leftChild and self.rightChild) class BST(object): """docstring for BST""" def __init__(self): self.size = 0 self.root = None def length(self): return self.size def insert(self,key,value): if self.root: self._insert(key,value,self.root) else: self.root = TreeNode(key,value) self.size += 1 return self.root def _insert(self,key,value,currentNode): if key &lt; currentNode.key: if currentNode.hasLeftChild(): self._insert(key,value,currentNode.leftChild) else: currentNode.leftChild = TreeNode(key,value,parent=currentNode) elif key == currentNode.key: currentNode.value = value else: if currentNode.hasRightChild(): self._insert(key,value,currentNode.rightChild) else: currentNode.rightChild = TreeNode(key,value,parent=currentNode)# def __setitem__(self,key,value):# self.insert(key,value) def get(self,key): if self.root: res = self._get(key,self.root) if res: return res.value else: return None else: return None def _get(self,key,currentNode): if currentNode is None: return None elif key == currentNode.key: return currentNode elif key &gt; currentNode.key: return self._get(key,currentNode.rightChild) else: return self._get(key,currentNode.leftChild)# def __getitem__(self,item):# return self.get(item)# def __contains__(self,item):# if self._get(item,self.root):# return True# else:# return Falseif __name__ == '__main__': tree = BST() #类的实例化 tree.insert(1,'dd') tree.insert(2,'d') tree.insert(3,'dde') tree.insert(4,'fafa') value = tree.get(4) print(value)]]></content>
      <tags>
        <tag>Data Structure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[链表]]></title>
    <url>%2F2018%2F08%2F21%2F%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[链表的概念何为链表链表是一种由节点(Node)组成的线性数据集合，每个节点通过指针指向下一个节点。它是一种由节点组成，并能够用于表示序列的数据结构 链表分类单链表每个节点仅指向下一个节点，最后一个节点指向空 双链表每个节点有两个指针p和n。p指向前一个节点，n指向下一个节点；最后一个节点指向空 循环列表每个节点指向下一个节点，最后一个节点指向第一个节点 链表的实现链表的反转单链表的反转可以使用循环，也可以使用递归的方式 代码如下: 12345678910111213141516171819class ListNode(object): def __init__(self,x): self.val = x self.next = None class Solution(object): def ReverseList(self,head): if head is None or head.next is None: return head p1 = head p2 = head.next tmp = None while p2: tmp = p2.next p2.next = p1 p1 = p2 p2 = tmp head.next = None return p1 ####]]></content>
      <categories>
        <category>Data Structures and Algorithms</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DNS原理及解析过程]]></title>
    <url>%2F2018%2F08%2F20%2FDNS%E5%8E%9F%E7%90%86%E5%8F%8A%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[网络通讯大部分是基于TCP/IP的，而TCP/IP是基于IP地址的，所以计算机在网络上进行通讯时只能识别如202.96.134.133之类的IP地址，而不能认识域名。我们无法记住10个以上网站的IP地址，所以我们访问网站时，更多的是在浏览器地址栏中输入域名，就能看到所需要的页面，这是因为有一个叫DNS服务器的计算机自动把我们的域名“翻译”成了相应的IP地址，然后调出IP地址所对应的网页。 什么是DNSDNS(Domain Name System)是域名系统的缩写，是一种组织成域层次结构的计算机和网络服务命名系统，它用于TCP/IP网络，它所提供的服务是用来将主机名和域名转换为IP地址的工作。DNS就是这样的一位“翻译官”，它的基本工作原理可用下图来表示。 DNS使用的协议DNS同时占用UDP和TCP端口53是公认的，这种单个应用协议同时使用两种传输协议的情况在TCP/IP栈也算是个另类。但很少有人知道DNS分别在什么情况下使用这两种协议。 DNS在进行区域传输的时候使用TCP协议，其它时候则使用UDP协议； DNS的规范规定了2种类型的DNS服务器，一个叫主DNS服务器，一个叫辅助DNS服务器。在一个区中主DNS服务器从自己本机的数据文件中读取该区的DNS数据信息，而辅助DNS服务器则从区的主DNS服务器中读取该区的DNS数据信息。当一个辅助DNS服务器启动时，它需要与主DNS服务器通信，并加载数据信息，这就叫做区传送（zone transfer）。 为什么既使用TCP又使用UDP？ 首先了解一下TCP与UDP传送字节的长度限制： UDP报文的最大长度为512字节，而TCP则允许报文长度超过512字节。当DNS查询超过512字节时，协议的TC标志出现删除标志，这时则使用TCP发送。通常传统的UDP报文一般不会大于512字节。 区域传送时使用TCP，主要有一下两点考虑： 辅域名服务器会定时（一般时3小时）向主域名服务器进行查询以便了解数据是否有变动。如有变动，则会执行一次区域传送，进行数据同步。区域传送将使用TCP而不是UDP，因为数据同步传送的数据量比一个请求和应答的数据量要多得多。 TCP是一种可靠的连接，保证了数据的准确性。 域名解析时使用UDP协议： 客户端向DNS服务器查询域名，一般返回的内容都不超过512字节，用UDP传输即可。不用经过TCP三次握手，这样DNS服务器负载更低，响应更快。虽然从理论上说，客户端也可以指定向DNS服务器查询的时候使用TCP，但事实上，很多DNS服务器进行配置的时候，仅支持UDP查询包。 DNS查询过程 在浏览器中输入&lt;www.qq.com&gt;域名，操作系统会先检查自己本地的hosts文件是否有这个网址映射关系，如果有，就先调用这个IP地址映射，完成域名解析。 如果hosts里没有这个域名的映射，则查找本地DNS解析器缓存，是否有这个网址映射关系，如果有，直接返回，完成域名解析。 如果hosts与本地DNS解析器缓存都没有相应的网址映射关系，首先会找TCP/ip参数中设置的首选DNS服务器，在此我们叫它本地DNS服务器，此服务器收到查询时，如果要查询的域名，包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析，此解析具有权威性。 如果要查询的域名，不由本地DNS服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个IP地址映射，完成域名解析，此解析不具有权威性。 如果本地DNS服务器本地区域文件与缓存解析都失效，则根据本地DNS服务器的设置（是否设置转发器）进行查询，如果未用转发模式，本地DNS就把请求发至13台根DNS，根DNS服务器收到请求后会判断这个域名(.com)是谁来授权管理，并会返回一个负责该顶级域名服务器的一个IP。本地DNS服务器收到IP信息后，将会联系负责.com域的这台服务器。这台负责.com域的服务器收到请求后，如果自己无法jing 解析，它就会找一个管理.com域的下一级DNS服务器地址(qq.com)给本地DNS服务器。当本地DNS服务器收到这个地址后，就会找qq.com域服务器，重复上面的动作，进行查询，直至找到&lt;www.qq.com&gt;主机。 如果用的是转发模式，此DNS服务器就会把请求转发至上一级DNS服务器，由上一级服务器进行解析，上一级服务器如果不能解析，或找根DNS或把转请求转至上上级，以此循环。不管是本地DNS服务器用是是转发，还是根提示，最后都是把结果返回给本地DNS服务器，由此DNS服务器再返回给客户机。]]></content>
      <tags>
        <tag>computer network</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库]]></title>
    <url>%2F2018%2F08%2F20%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[存储过程我们常用的操作数据库语言SQL语句在执行的时候需要要先编译，然后执行，而存储过程（Stored Procedure）是一组为了完成特定功能的SQL语句集，经编译后存储在数据库中，用户通过指定存储过程的名字并给定参数（如果该存储过程带有参数）来调用执行它。 一个存储过程是一个可编程的函数，它在数据库中创建并保存。它可以有SQL语句和一些特殊的控制结构组成。当希望在不同的应用程序或平台上执行相同的函数，或者封装特定功能时，存储过程是非常有用的。数据库中的存储过程可以看做是对编程中面向对象方法的模拟。它允许控制数据的访问方式。 存储过程通常有以下优点： (1).存储过程增强了SQL语言的功能和灵活性。存储过程可以用流控制语句编写，有很强的灵活性，可以完成复杂的判断和较复杂的运算。 (2).存储过程允许标准组件是编程。存储过程被创建后，可以在程序中被多次调用，而不必重新编写该存储过程的SQL语句。而且数据库专业人员可以随时对存储过程进行修改，对应用程序源代码毫无影响。 (3).存储过程能实现较快的执行速度。如果某一操作包含大量的Transaction-SQL代码或分别被多次执行，那么存储过程要比批处理的执行速度快很多。因为存储过程是预编译的。在首次运行一个存储过程时查询，优化器对其进行分析优化，并且给出最终被存储在系统表中的执行计划。而批处理的Transaction-SQL语句在每次运行时都要进行编译和优化，速度相对要慢一些。 (4).存储过程能过减少网络流量。针对同一个数据库对象的操作（如查询、修改），如果这一操作所涉及的Transaction-SQL语句被组织程存储过程，那么当在客户计算机上调用该存储过程时，网络中传送的只是该调用语句，从而大大增加了网络流量并降低了网络负载。 (5).存储过程可被作为一种安全机制来充分利用。系统管理员通过执行某一存储过程的权限进行限制，能够实现对相应的数据的访问权限的限制，避免了非授权用户对数据的访问，保证了数据的安全。 SQL语言对数据库进行查询和修改操作的语言叫做SQL。 SQL包含以下4个部分。 数据定义语言(DDL): DROP, CREATE, ALTER等语句 数据擦操作语言(DML): INSERT(插入)， UPDATE(修改)，DELETE(删除)语句 数据查询语言(DQL): SELECT 数据控制语言(DCL): GRANT, REVOKE,COMMIT, ROLLBACK等语句 数据库的锁锁锁是网络数据库中非常重要的概念，当多个用户同时对数据库并发操作时，会带来数据的不一致问题，所以，锁主要用于多用户环境中保证数据完整性和一致性。 数据库锁出现的目的：处理并发问题 并发控制的主要采取手段有：乐观锁、悲观锁和时间戳 锁分类从数据库系统的角度分为三种：排它锁、共享锁、更新锁 从程序员的角度分为两种：一种是乐观锁、一种是悲观锁 悲观锁(Pessimistic Lock)顾名思义，很悲观，每次去拿数据的时候都被认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人拿这个数据就会被block(阻塞)，直到它拿到锁。 传统的关系型数据库里用到了很多这种锁机制，比如行锁、表锁、读锁、写锁等，都是在操作之前先上锁。 悲观锁按性质划分共享锁（Share Lock）S锁，也叫读锁，用于所有的只读数据操作。共享锁是非独占的，允许多个并发事务读取其锁定的资源。 性质： 多个事务可封锁同一个共享页； 任何事务都不能修改该页 通常是该页被读取完毕，S锁立即被释放 排它锁（Exclusive Lock）X锁，也叫写锁，表示对数据进行写操作。如果一个事务对对象加了排它锁，其它事务就不能再给他加任何锁了。 性质： 仅允许一个事务封锁此页 其他任何事务必须等释放才能对该页进行访问 X锁一直到事务结束才能释放 更新锁U锁，在修改操作的初始化阶段用来锁定可能要被修改的资源，这样可以避免使用共享锁造成的死锁现象。 性质： 用来预定要对此页施加X锁，它允许其它事务读，但不允许在施加U锁或X锁 当被读取的页要被更新时，则升级为X锁； U锁一直到事务结束才能被释放 悲观锁按作用范围划分为：行锁、表锁 行锁： 锁的作用范围是行级别 表锁： 锁的作用范围是整张表 乐观锁顾明思义，就是很乐观，每次去拿数据的时候都被认为别人不会修改。所以，不会上锁。但是在更新的时候会判断一下此期间有没有人更新这个数据，可以使用版本号等机制。 乐观锁适用于多读写少的应用场景，这样可以提高吞吐量，像数据库如果提供类似write_condition机制的其实都是提供的乐观锁。 乐观锁的实现方式 版本号（version） 版本号（记为version）：就是给数据增加一个版本标识，在数据库上就是表中增加一个version字段，每次更新把这个字段加1，读取数据的时候把version读出来，更新的时候比较version，如果还是开始读取的version就可以更新了，如果现在的version比老的version大，说明有其他事务更新了该数据，并增加了版本号，这时候得到一个无法更新的通知，用户自行根据这个通知来决定怎么处理，比如重新开始一遍。这里的关键是判断version和更新两个动作需要作为一个原子单元执行，否则在你判断可以更新以后正式更新之前有别的事务修改了version，这个时候你再去更新就可能会覆盖前一个事务做的更新，造成第二类丢失更新，所以你可以使用update … where … and version=”old version”这样的语句，根据返回结果是0还是非0来得到通知，如果是0说明更新没有成功，因为version被改了，如果返回非0说明更新成功。 时间戳（使用数据库服务器的时间戳） 时间戳（timestamp）：和版本号基本一样，只是通过时间戳来判断而已，注意时间戳要使用数据库服务器的时间戳不能是业务系统的时间。 待更新字段 待更新字段：和版本号方式相似，只是不增加额外字段，直接使用有效数据字段做版本控制信息，因为有时候我们可能无法改变旧系统的数据库表结构。假设有个待更新字段叫count,先去读取这个count,更新的时候去比较数据库中count的值是不是我期望的值（即开始读的值），如果是就把我修改的count的值更新到该字段，否则更新失败。java的基本类型的原子类型对象如AtomicInteger就是这种思想。 所有字段 所有字段：和待更新字段类似，只是使用所有字段做版本控制信息，只有所有字段都没变化才会执行更新。 数据库索引为什么用B树？原理是啥事务处理什么是事务- transaction事务(Transaction)是并发控制的基本单位。所谓事务,它是一个操作序列；使用事务处理，通过确保成批的SQL操作要么都执行，要么都不执行，来维护数据库的完整性。例如，银行转帐工作：从一个帐号扣款并使另一个帐号增款，这两个操作要么都执行，要么都不执行。所以，应该把他们看成一个事务。事务是数据库维护数据一致性的单位，在每个事务结束时，都能保持数据一致性。 事务处理的几个处理 事务(transaction)：指一组SQL语句 回退(rollback)：指撤销指定的SQL语句的过程 提交(commit)：指将未存储的SQL语句结果写入数据库表 保留点(savepoint)：指事务处理中设置的零时占位符(placeholder),可以对它发布回退 数据库事务的四大特性数据库事务必须具备ACID特性，Atomic(原子性)，Consistency(一致性)，Isolation(隔离性)和Durability(持久性)： 原子性：指整个数据库事务是不可分割的工作单位。事务中的操作要么发生，要么没发生，不存在发生一半的情况 一致性：一致性也称为完整性。一个事务在执行后，数据库必须从一个一致性状态转变为另一个一致性状态。 隔离性：指的是在并发环境中，当不同的事务同时操纵相同的数据时，每个事务都有自己各自完整的数据空间，互不干扰 持久性：指的是只要事务成功结束，它对数据库所做的更新就必须永久保存下来 数据库的隔离级别名词解释脏读所谓脏读就是指一个事务中访问到了另外一个事务中未提交的数据，如下： 如上图开启两个会话来模拟两个线程同时去访问数据库表table中id=1的记录，假设两个会话开启前数据库中table表中id=1的记录行里面的列age值为5。会话1和2一开始都开启了显示的事务（只有执行commit命令才会提交数据的修改），会话2首先更新了table中id=1的记录行的age列的值为10（更新前值为5），在会话2执行commit提交前，会话1通过select语句查询id=1的记录行中age列的值，这时候如果存在脏读，则会话1读取到的age的值是10而不是5了，虽然会话2的更新还没有提交。那么脏读存在什么问题那?如果会话2最后提交了，那么会话1虽然在会话2还没提交就读取到了修改的值，但是也没什么影响；但是如果会话1读取到会话2没有提交的数据后，会话2执行了rollback，也就是没有把修改刷新到数据库，但是会话1已经使用了修改的数据，这就出现了错误。 不可重复读所谓不可重复读是指在一个事务内根据同一个条件对记录进行多次查询，但是搜出来的结果却不一致。发生不可重复读的原因是在多次搜索期间查询条件覆盖的数据被其他事务修改了，如图： 如上图假设数据库表table里面id=1的记录行中age列一开始值为5，然后会话1和会话2分别开启了一个事务，会话1首先查询id=1的记录中age字段值为5，然后会话2修改id=1的记录中age的值为10然后提交了事务，然后会话1再次搜出id=1的记录中age的值，如果出现了不可重复读，则这时候搜出来的age的值为10而不是5。需要注意的是会话1两次查询是在同一个事务内进行的，期间事务并没有提交。不可重复读的存在显得不是那么不可容忍，毕竟读取的是已经提交了的数据。 幻读所谓幻读是指同一个事务内多次查询返回的结果集不一样(比如在增加了或者减少了行记录)。比如同一个事务A内第一次查询的时候有n条记录，但是第二次同等条件下查询却有n+1条记录，这就好像产生了幻觉。其实和不可重复读一样发生幻读的原因也是另外一个事务新增或者删除或者修改了第一个事务结果集里面的数据。不同在于不可重复读是同一个记录内容被改变了。幻读是数据行记录变多了或者变少了。 如上图假设表table里面一开始有一个id=3的记录，会话1首先开启了一个事务，然后查找id&gt;2的记录，会发现结果只有一个记录，然后会话2开启事务插入了id=5的一个记录，然后提交。这时候会话1再次查找id&gt;2的记录，如果存在幻读，则这时候会话1会看到两条记录。 注：脏读是指一个事务读取到了其他事务没有提交的数据，不可重复读是指一个事务内多次根据同一个查询条件查询出来的同一行记录的值不一样，幻读是指一个事务内多次根据同个条件查出来的记录行数不一样。为了解决事务并发带来的问题，才有了事务规范中的四个事务隔离级别，不同隔离级别对上面问题部分或者全部做了避免。 隔离级别数据库事务的隔离级别有4个，由高到低依次为Read Uncommitted, Read committed, Repeatable read, Serializable这四个级别可以逐个解决脏读、不可重复读、幻读这几类问题。 脏读 不可重复读 幻读 Read uncommitted 可能出现 可能出现 Read committed 不会出现 可能出现 可能出现 Repeatable read 不会出现 不会出现 可能出现 Serializable 不会出现 不会出现 不会出现 Read uncommitted 读未提交公司发工资了，领导把5000元打到singo的账号上，但是该事务并未提交，而singo正好去查看账户，发现工资已经到账，是5000元整，非常高 兴。可是不幸的是，领导发现发给singo的工资金额不对，是2000元，于是迅速回滚了事务，修改金额后，将事务提交，最后singo实际的工资只有 2000元，singo空欢喜一场。 出现上述情况，即我们所说的脏读 ，两个并发的事务，“事务A：领导给singo发工资”、“事务B：singo查询工资账户”，事务B读取了事务A尚未提交的数据。 当隔离级别设置为Read uncommitted 时，就可能出现脏读，如何避免脏读，请看下一个隔离级别。 Read committed 读提交singo拿着工资卡去消费，系统读取到卡里确实有2000元，而此时她的老婆也正好在网上转账，把singo工资卡的2000元转到另一账户，并在 singo之前提交了事务，当singo扣款时，系统检查到singo的工资卡已经没有钱，扣款失败，singo十分纳闷，明明卡里有钱，为 何…… 出现上述情况，即我们所说的不可重复读 ，两个并发的事务，“事务A：singo消费”、“事务B：singo的老婆网上转账”，事务A事先读取了数据，事务B紧接了更新了数据，并提交了事务，而事务A再次读取该数据时，数据已经发生了改变。 当隔离级别设置为Read committed 时，避免了脏读，但是可能会造成不可重复读。 大多数数据库的默认级别就是Read committed，比如Sql Server , Oracle。如何解决不可重复读这一问题，请看下一个隔离级别。 Repeatable read 重复读当隔离级别设置为Repeatable read 时，可以避免不可重复读。当singo拿着工资卡去消费时，一旦系统开始读取工资卡信息（即事务开始），singo的老婆就不可能对该记录进行修改，也就是singo的老婆不能在此时转账。 虽然Repeatable read避免了不可重复读，但还有可能出现幻读 。 singo的老婆工作在银行部门，她时常通过银行内部系统查看singo的信用卡消费记录。有一天，她正在查询到singo当月信用卡的总消费金额 （select sum(amount) from transaction where month = 本月）为80元，而singo此时正好在外面胡吃海塞后在收银台买单，消费1000元，即新增了一条1000元的消费记录（insert transaction … ），并提交了事务，随后singo的老婆将singo当月信用卡消费的明细打印到A4纸上，却发现消费总额为1080元，singo的老婆很诧异，以为出 现了幻觉，幻读就这样产生了。 注：Mysql的默认隔离级别就是Repeatable read。 Serializable 序列化Serializable 是最高的事务隔离级别，同时代价也花费最高，性能很低，一般很少使用，在该级别下，事务顺序执行，不仅可以避免脏读、不可重复读，还避免了幻像读。]]></content>
      <categories>
        <category>Database</category>
      </categories>
      <tags>
        <tag>interview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ARP协议]]></title>
    <url>%2F2018%2F08%2F20%2FARP%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[关于ARP地址解析协议的讲解 ARP协议MAC地址计算机是通过网卡上网的，每台计算机中的网卡在出厂时就会被编制一个独一无二的号码固化到网卡中，这个号码就是MAC地址。而ARP协议就是用来获取MAC地址的。 ARP概念ARP协议，Address Resolution Protocol 地址解析协议，是网络层的一个协议。 网络通信需要知道对方的ip地址，但是ip只存在于协议的第三层，而实际发送数据到网络上的另一台主机是由物理层负责的，那在物理层怎么把数据传递给对方呢，就需要MAC地址。 在局域网中，网路中实际传输的是帧，帧里面是有目标主机的MAC地址。在以太网中，一个主机要和另一个主机进行直接通信，必须要知道目标主机的MAC地址。但是这个地址是如何获取的呢？他就是通过地址解析协议获得的。所谓“地址解析”就是主机在发送帧之前金目标主机的IP地址转换成为目标主机的MAC地址的过程。ARP协议的基本功能就是通过目标主机的IP地址，查询目标主机的MAC地址，以保证通信的顺利进行。协议又称做服务，ARP协议也即ARP服务，提供把IP地址转换成MAC地址的服务。 在现行寻址机制中，主机的以太网网卡只能识别MAC地址，而不能识别IP地址，若数据帧中不指明主机B的MAC地址，主机B的网卡不能识别该帧是发给自己的，因此主机A仅知道主机B的IP地址还不够，还必须知道主机B的MAC地址，才能完成对主机B的访问；网络之间是用IP地址寻址，网络之内（同一物理网段或称IP子网）是用MAC地址寻址。 ARP理解示例为了理解ARP协议的作用，这里举一个简答的ping命令例子 假设在一个局域网中，（注意这里的前提是两台主机在同一局域网中）我们的计算机IP地址是192.168.1.1，现在DOS窗口中执行这个命令：ping192.168.1.2。该命令会通过ICMP协议（互联网控制报文协议）发送ICMP数据 包。该过程需要经过下面的步骤： 应用程序构造数据包，该步骤是产生ICMP包，然后把它提交给内核（网卡驱动程序）； 内核检查是否能够转化该IP地址为MAC地址，也就是在本地的ARP缓存中查看IP-MAC对应表； 如果存在该IP-MAC对应关系，那么跳到步骤7；如果不存在该IP-MAC对应关系，那么接续下面的步骤； 内核进行ARP广播，即发送 ARP Request，向整个网络中大喊，这个IP是谁的，这个IP是谁的（这个ARP Request中包含有我们计算机的MAC地址； 当192.168.1.2主机接收到该ARP请求后，就发送一个ARP 回应，即ARP REPLY命令，说道：这个IP是我的，你看这是我的MAC地址（ARP Request中包含自己的MAC地址）； 我们的计算机获得192.168.1.2主机的IP-MAC地址对应关系，就保存到自己的ARP缓存中； 内核将把目标主机IP转化为MAC地址，然后封装在以太网头结构中，再把数据发送出去； 这样主机B看到发送过来的数据包包头里有自己的MAC地址，才会识别它，噢，这个数据是发送给我的（当数据包包头里只有B的IP地址时，主机B会不认识它，不去接收这个数据包） IP地址就像人的姓名，MAC地址就像人的身份证，当一个包裹发送过来，上面写着，是给张三的，但是叫张三的多了，张三不会去接收，但是包裹上面写了张三的身份证号码，张三一看，啊，是我的，身份证是唯一的，他才接收。那IP的作用是什么呢？ IP地址具有全网范围内的寻址能力，主机A和B可能分别处在不同网络，主机A要访问主机B首先要知道主机B的IP地址，不然找不到主机B所在 的网络。也就是说有了主机B的IP地址，主机A会知道主机B在哪里，知道它所在的网络，但不会把数据给它，只有得到它的MAC地址，之后，才会给它，就像验证身份证一样。 使用 arp -a 命令就可以查看本地的ARP缓存内容，所以，执行一个本地的PING命令后，ARP缓存就会存在一个目的IP的记录了。当 然，如果你的数据包是发送到不同网段的目的地，那么就一定存在一条网关的IP-MAC地址对应的记录。 知道了ARP协议的作用，就能够很清楚地知道，数据包的向外传输是非常依赖MAC地址，可以看出ARP协议在网络传输中的不可缺少的作用。 假如说两台主机不在同一局域网，即便知道目的主机的MAC地址，两者也不能直接通信，必须经过路由转发才可以。所以此时，发送主机通过ARP协议获得的将不是目的主机的MAC地址，而是一台可以通往局域网外的路由器的某个端口的MAC地址。于是此后发送主机发往目的主机的所有帧，都将发往该路由器，通过它向外发送。这种情况称为ARP代理（ARP Proxy）。也就是说，本地主机当寻求一个IP地址的MAC时，找不到，不是同一局域网，那它会收到路由器的MAC地址，说，这个数据就交给你了，剩下的事就你来处理了，你去找目的主机吧！ 每次都要用ARP request来寻求MAC是很低效的，ARP cache则很好的解决了这个问题 通信流程 假设主机A(135.24.25.23)第一次和统一网段内的主机B(135.24.25.32)通信 A封装好了要发送的信息，在写通讯地址时 A会用子网掩码进行计算先判断B和A是不是在一个网段，这时候A知道和B是一个网段 所以A会直接发送一个ARP包，B在收到这个包之后会发现是给自己发的， 此时B也会封装一个ARP包来告诉A B自己的MAC地址 这样A就知道了B的MAC地址，就可以完成报文的封装，发送给B 假设主机A(135.24.25.23)第一次和不同的网段的主机C(135.24.52.133)通信: A会用子网掩码进行计算先判断B和A自己在不在同一个网段，这时候A知道了B和自己不在一个网段， 这时候，A知道该用网关把自己的数据传递给C，所以A会发送一个ARP包来获取网关的MAC地址， 网关收到ARP包后，把自己的MAC地址封装在ARP包中，发送给A， A封装报文，目标MAC地址写网关的MAC地址， 网关收到报文，发现是给自己发的，就开始解包，解开之后，发现是给另一个网段的主机发送的， 此时如果网管本身就是路由器就直接把数据报文发送给下一跳路由器，如果网关是普通的PC，就发送给路由器，由路由器发送给下一跳路由器，目标MAC写下一跳路由器的MAC地址， 历经千辛万苦，报文终于到达C的主机的路由器，路由器发送报文到C所在网段的网关， C网段的网关解包之后发现不是给自己，而是给自己网段内的C主机，就发送报给给C ARP高速缓存知道了ARP发送原理后，如果每次发送之前都要发送ARP请求硬件地址会不会太慢，但是实际上ARP的运行时非常高效。那是因为每一个主机上都有一个ARP高速缓存，我么可以在命令行键入arp -a获取本机ARP高速缓存的所有内容。 高速缓存中的每一项生存时间一般为20分钟，有了这些缓存，我们经常直接使用硬件地址，加快速度了。]]></content>
      <tags>
        <tag>TCP/IP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++面试题1]]></title>
    <url>%2F2018%2F08%2F20%2FC%2B%2B%E5%9F%BA%E7%A1%801%2F</url>
    <content type="text"><![CDATA[C++有哪些性质封装、继承和多态 const有什么用途主要有三点; 定义只读变量，即常量 修饰函数的参数和函数的返回值 修饰函数的定义体，这里的函数为类的成员函数，被 const 修饰的成员函数代表不修改成员变量的值 指针和引用的区别 引用是变量的一个别名，内部实现是只读指针 引用只能在初始化时被赋值，其他时候值不能被改变，指针的值可以在任何时候被改变 引用不能为 NULL，指针可以为 NULL 引用变量内存单元保存的是被引用变量的地址 “sizeof 引用” = 指向变量的大小 ， “sizeof 指针”= 指针本身的大小 引用可以取地址操作，返回的是被引用变量本身所在的内存单元地址 引用使用在源代码级相当于普通的变量一样使用，做函数参数时，内部传递的实际是变量地址 new和malloc的区别对继承、封装和多态的理解如何实现多态初始化列表析构函数一定是虚函数吗说一下构造函数的执行顺序，析构函数呢]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[管理数据内存的方式]]></title>
    <url>%2F2018%2F08%2F20%2F%E7%AE%A1%E7%90%86%E6%95%B0%E6%8D%AE%E5%86%85%E5%AD%98%E7%9A%84%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[根据用于分配内存的方法，C++有3种管理数据内存的方式: 自动存储、静态存储和动态存储。 自动存储 在函数内部定义的常规变量使用自动存储空间，被称为自动变量，这意味着他们在所属的函数被调用时自动产生，在函数结束时消亡。 实际上，自动变量是一个局部变量，其作用域为包含它的代码块。代码块是被包含在花括号中的一段代码。 自动变量通常存储在栈中。这意味着执行代码块时，其中的变量将依次加入到栈中，而在离开代码块时，将按相反的顺序释放这些变量，这被称为后进先出(LIFO)。在程序执行的过程中，栈将不断增大和缩小。 静态存储 静态存储是整个程序执行期间都存在的存储方式。使变量称为静态的方式有两种：一种是在函数外面定义它；另一种是在声明变量时使用关键字static: static double fee = 56.30 动态存储 new和delete运算符提供了一种比自动变量和静态变量更灵活的方法。他们管理了一个内存池，这在C++中被成为诶你自由存储空间或堆。该内存池同用于静态变量和自动变量的内存是分开的。new和delete可以让你能够在一个函数中分配内存，而在另一个函数中释放它。因此，数据的生命周期不完全受程序或者函数的生存时间控制。]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[const限定符总结]]></title>
    <url>%2F2018%2F08%2F20%2FC%2B%2B%E7%9A%84const%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[const 限定符修饰基本数据类型修饰一般常量及数组const int a=10 或者 int const a=10 修饰指针变量*指针: 是用来指向实际内存地址的变量 引用: 是其相应变量的别名 当使用带有const的指针的时候其实有两个意思。一种是你不能修改指针本身的内容，另一种是你不能修改指针指向的内容。 指针指向的内容不能更改 const int* p（推荐） 或者 int const* p 指针本身的值不能更改 int* const p=&amp;address 指针本身和它指向对的内容都不能更改 const int* const p=&amp;address 修饰引用(&amp;)int const &amp;a=x 或者 const int &amp;a=x 这两种定义方式是等价的，但是此时引用a不能被更新。如a++是错误的 define与const的区别c++中不但可以使用define定义常量还可以用const定义常量，区别如下： 用define Max 255定义的常量是没有类型的，所给出的是一个立即数，编译器只是把所定义的常量值与所定义的常量的名字联系起来，define所定义的宏变量在预处理的时候进行替换，在程序中使用到该常量的地方首要进行拷贝替换 用const float MAX = 255定义的常量有类型的名字，存放在内存的静态区域中，在程序运行过程中const变量只有一个拷贝，而# define定义的宏变量却有多个拷贝，所以宏定义在程序运行过程中所消耗的内存要比const变量的大得多 用define定义的常量是不可以用指针变量去指向的，用const定义的常量是可以用指针去指向该常量的地址的 用define可以定义一些简单的函数，const是不可以定义函数的 具体来说，有以下几方面的区别 编译器的处理方式 define 在预处理阶段进行替换 const 在编译运行确定其值 类型检查 define 无类型，不进行 类型安全检查，可能会产生意想不到的错误 const 有数据类型，编译时会进行类型检查 存储空间 define 不分配内存 ，给出的是立即数，有多少次使用就进行多少次替换，在内存中会有多个拷贝，消耗内存大 const 在静态存储区中分配空间，在程序运行过程中内存中只有一个拷贝 其它 在编译时， 编译器通常不为const常量分配存储空间，而是将它们保存在符号表中，这使得它成为一个编译期间的常量，没有了存储与读内存的操作，使得它的效率也很高。宏替换只作替换，不做计算，不做表达式求解。 宏定义的作用范围仅限于当前文件。默认状态下，const对象只在文件内有效，当多个文件中出现了同名的const变量时，等同于在不同文件中分别定义了独立的变量。如果想在多个文件之间共享const对象，必须在变量定义之前添加extern关键字（在声明和定义时都要加）]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[进程间的通信方式]]></title>
    <url>%2F2018%2F08%2F19%2F%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[进程的概念进程是操作系统的概念，每当我们执行一个程序时，对于操作系统来讲就创建了一个进程，在这个进程中，伴随着资源的分配和释放。可以认为进程是一个程序的一次执行过程。 进程通信的概念进程用户空间是相互独立的，一般而言是不能相互访问的。但很多情况下进程间需要相互通信，来完成系统的某项功能。进程通过与内核及其他进程之间的相互同信来协调他们的行为。 进程通信的应用场景 数据传输：一个进程需要将它的数据发送给另一个进程，发送的数据量在一个字节到几兆字节之间。 共享数据：多个进程想要操作共享数据，一个进程对共享数据的修改，别的进程应该立刻看到。 通知事件：一个进程需要向另一个或一组进程发送消息，通知它（它们）发生了某种事件（如进程终止时要通知父进程）。 资源共享：多个进程之间共享同样的资源。为了作到这一点，需要内核提供锁和同步机制。 进程控制：有些进程希望完全控制另一个进程的执行（如Debug进程），此时控制进程希望能够拦截另一个进程的所有陷入和异常，并能够及时知道它的状态改变。 进程通信的方式管道（Pipe）管道包含三种： 普通管道PIPE: 通常有两种限制，一种是单工，只能是单向传递；二是只能在父子或者兄弟进程间使用 流管道s_pipe：去除了第一种限制，为半双工，只能在父子或兄弟进程间使用，可以双向传输 命名管道:name_pipe：去除了第二种限制,可以在许多并不相关的进程之间进行通讯. 信号量（Semophore）信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。 消息队列（message queue）消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。 信号（Signal）信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。 共享内存（Shared memory）共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。 套接字套解字也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同机器间的进程通信。 各进程间通信原理管道管道是如何通信的管道是由内核管理的一个缓冲区，相当于我们放入内存中的一个纸条。管道的一端连接一个进程的输出。这个进程会向管道中放入信息。管道的另一端连接一个进程的输入，这个进程取出被放入管道的信息。一个缓冲区不需要很大，它被设计成为环形的数据结构，以便管道可以被循环利用。当管道中没有信息的话，从管道中读取的进程会等待，直到另一端的进程放入信息。当管道被放满信息的时候，尝试放入信息的进程会等待，直到另一端的进程取出信息。当两个进程都终结的时候，管道也自动消失。 管道是如何创建的从原理上，管道利用fork机制建立，从而让两个进程可以连接到同一个PIPE上。最开始的时候，上面的两个箭头都连接在同一个进程Process 1上(连接在Process 1上的两个箭头)。当fork复制进程的时候，会将这两个连接也复制到新的进程(Process 2)。随后，每个进程关闭自己不需要的一个连接 (两个黑色的箭头被关闭; Process 1关闭从PIPE来的输入连接，Process 2关闭输出到PIPE的连接)，这样，剩下的红色连接就构成了如上图的PIPE。]]></content>
      <categories>
        <category>Operating System</category>
      </categories>
      <tags>
        <tag>Operating System</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python面试题1]]></title>
    <url>%2F2018%2F08%2F19%2FPython%E5%9F%BA%E7%A1%801%2F</url>
    <content type="text"><![CDATA[Python的特性关键特性 Python是一种解释性语言，这意味着，与C、C++不同，Python不需要再运行之前进行编译。它是边运行边解释的。 Python是动态类型化的，这意味这你不需要声明变量的类型 在Python中函数是一等对象，这意味着它们可以在运行时动态创建，能复制给变量或者作为参数传给函数，还能作为函数的返回值 单引号、双引号和三引号之间的区别单引号和双引号主要是用来标表示字符串 比如 单引号’python’ 双引号”python” 区别 若你的字符串里本身包含单引号，必须用双引号包裹。 如： “Can’t find the log” 三引号 三单引号:’’’python ‘’’,也可以表示字符串，一般用来输入多行文本,或者用于大段的注释。 三双引号：”””python”””，一般用在类里面,用来注释类,这样省的写文档,直接用类的对象doc访问获得文档。 什么是lambda函数？它的好处是什么lambda表达式，通常指是在需要一个函数，但是又不想费神的去命名一个函数的场合下使用，也就是指匿名函数。 ma Python里面的search()和match()的区别match()函数只检测RE是不是在string的开始位置匹配，search()会扫描整个string查找匹配，也就是说match()只有在0位置匹配成功的话才有返回，如果不是开始位置匹配成功的话，match()就返回None 如何将一个数字转换成一个字符串你可以使用自带函数str()将一个数字转换为字符串。如果你想要八进制或者十六进制数，可以用oct()或hex() python中装饰器的作用装饰器本质上是一个Python函数，它可以让其他函数在不需要做任何代码变动的前提下增加额外功能，装饰器的返回值也是一个函数对象。它经常用于有切面需求的场景，比如：插入日志、性能测试、事务处理、缓存、权限校验等场景。装饰器是解决这类问题的绝佳设计，有了装饰器，我们就可以抽离出大量与函数功能本身无关的雷同代码并继续重用。概括的讲，装饰器的作用就是为已经存在的对象添加额外的功能。 *args和**kwargs是什么意思*args表示可变参数（variadic arguments），它允许你传入0个或任意个无名参数，这些参数在函数调用时自动组装为一个tuple； **kwargs表示关键字参数（keyword arguments），它允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict。同时使用\args和**kwargs的时候，必须保证*args在**kwargs之前。 pyhton和C++区别程序有两种执行方式，解释执行和编译执行。Python是一种脚本语言，是杰解释执行的，不需要经过，所以很方便，且能够很好的跨平台。而C++则是一种需要编译够运行的语言，在特定的机器上编译在特定的机器上运行，运行效率高，安全稳定。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>interview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP与UDP协议]]></title>
    <url>%2F2018%2F08%2F19%2FTCP%E4%B8%8EUDP%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[TCPTCP 报文格式格式如下： 各字段解释： 源端口、目标端口：计算机上的进程要和其他进程通信是要通过计算机端口的，而一个计算机端口某个时刻只能被一个进程占用，所以通过指定源端口和目标端口，就可以知道是哪两个进程需要通信。源端口、目标端口是用16位表示的，可推算计算机的端口个数为2^16个。 序列号(Sequence number)：该字段标识了TCP发送端到TCP接收端的数据流的一个字节，该字节代表着包含该序列号的报文段中的数据的第一个字节。在TCP连接中所传送的字节流的每一个字节都会按顺序编号。由于序列号由32位表示，所以每2^32个字节，就会出现序列号回绕，再次从 0 开始。那如何区分两个相同序列号的不同TCP报文段就是一个问题了，后面会有答案，暂时可以不管。 确认号(ACK)：包含的值是该确认号发送方期望收到下一个序列号。也就是告诉发送发：我希望你（指发送方）下次发送的数据的第一个字节数据的编号是这个确认号。也就是告诉发送方：我希望你（指发送方）下次发送给我的TCP报文段的序列号字段的值是这个确认号。 TCP头部长度：由于TCP首部包含一个长度可变的选项部分，所以需要这么一个值来指定这个TCP报文段到底有多长。或者可以这么理解：就是表示TCP报文段中数据部分在整个TCP报文段中的位置。该字段的单位是32位字，即：4个字节。 URG：表示本报文段中发送的数据是否包含紧急数据。URG=1，表示有紧急数据。后面的紧急指针字段只有当URG=1时才有效。 ACK：表示是否前面的确认号字段是否有效。ACK=1，表示有效。只有当ACK=1时，前面的确认号字段才有效。TCP规定，连接建立后，ACK必须为1。 PSH：告诉对方收到该报文段后是否应该立即把数据推送给上层。如果为1，则表示对方应当立即把数据提交给上层，而不是缓存起来。 RST：只有当RST=1时才有用。如果你收到一个RST=1的报文，说明你与主机的连接出现了严重错误（如主机崩溃），必须释放连接，然后再重新建立连接。或者说明你上次发送给主机的数据有问题，主机拒绝响应。 SYN：在建立连接时使用，用来同步序号。当SYN=1，ACK=0时，表示这是一个请求建立连接的报文段；当SYN=1，ACK=1时，表示对方同意建立连接。SYN=1，说明这是一个请求建立连接或同意建立连接的报文。只有在前两次握手中SYN才置为1。 FIN：标记数据是否发送完毕。如果FIN=1，就相当于告诉对方：“我的数据已经发送完毕，你可以释放连接了” 窗口大小：表示现在运行对方发送的数据量。也就是告诉对方，从本报文段的确认号开始允许对方发送的数据量。 校验和：提供额外的可靠性 紧急指针：标记紧急数据在数据字段中的位置。 选项部分：其最大长度可根据TCP首部长度进行推算。TCP首部长度用4位表示，那么选项部分最长为：(2^4-1)*4-20=40字节。 选项部分的应用： MSS最大报文段长度(Maxium Segment Size)：指明数据字段的最大长度，数据字段的长度加上TCP首部的长度才等于整个TCP报文段的长度。MSS值指示自己期望对方发送TCP报文段时那个数据字段的长度。通信双方可以有不同的MSS值。如果未填写，默认采用536字节。MSS只出现在SYN报文中。即：MSS出现在SYN=1的报文段中。 窗口扩大选项(Windows Scaling)：由于TCP首部的窗口大小字段长度是16位，所以其表示的最大数是65535。但是随着时延和带宽比较大的通信产生（如卫星通信），需要更大的窗口来满足性能和吞吐率，所以产生了这个窗口扩大选项。 SACK选择确认项(Selective Acknowledgements)：用来确保只重传缺少的报文段，而不是重传所有报文段。比如主机A发送报文段1、2、3，而主机B仅收到报文段1、3。那么此时就需要使用SACK选项来告诉发送方只发送丢失的数据。那么又如何指明丢失了哪些报文段呢？使用SACK需要两个功能字节。一个表示要使用SACK选项，另一个指明这个选项占用多少字节。描述丢失的报文段2，是通过描述它的左右边界报文段1、3来完成的。而这个1、3实际上是表示序列号，所以描述一个丢失的报文段需要64位即8个字节的空间。那么可以推算整个选项字段最多描述(40-2)/8=4个丢失的报文段。 时间戳选项（Timestamps）：可以用来计算RTT(往返时间)，发送方发送TCP报文时，把当前的时间值放入时间戳字段，接收方收到后发送确认报文时，把这个时间戳字段的值复制到确认报文中，当发送方收到确认报文后即可计算出RTT。也可以用来防止回绕序号PAWS，也可以说可以用来区分相同序列号的不同报文。因为序列号用32为表示，每2^32个序列号就会产生回绕，那么使用时间戳字段就很容易区分相同序列号的不同报文。 NOP(NO-Operation)：它要求选项部分中的每种选项长度必须是4字节的倍数，不足的则用NOP填充。同时也可以用来分割不同的选项字段。如窗口扩大选项和SACK之间用NOP隔开。 TCP的三次握手和四次挥手建立TCP需要三次握手才能建立，而断开连接则需要四次握手。整个过程如下图所示 TCP通信过程包括三个步骤: 建立TCP连接通道，数据传输，断开TCP连接通道。 三次握手 一个TCP的连接通常分为3段：启动、数据传输、退出。 第一次握手(SYN=1,seq=x) 主动开启者(通常称为客户端)发送一个SYN报文段(即一个在TCP头部的SYN位字段置位的TCP/IP数据包)，并指明自己想要连接的端口号和它的客户端初始序列号(记为ISN)。发送完毕后，客户端进入SYN_SEND的状态。客户端发送的这个SYN报文段称作段1. 第二次握手:(SYN=1,seq=y,acknum=x+1，ACK =1) 服务器也会发送自己的SYN报文段作为响应，即SYN标志位和ACk标识位均为1.服务器选择自己的序列号，放到seq内，同时将确认序号设置为客户端的seq+1,发送完毕后，服务器进入SYN_RCVD状态。该段称为段2。 第三次握手(ACK=1,AckNum=y+1) 客户端再次发送确认包(ACK),SYN标志位为0，ACK标志位为1，并且服务器发来的ACK的序号字段+1，放在确认字段中发送给对方，并且在数据段ACKnum = y+1.发送完毕后，客户端进入ESTABLISHED状态，当服务器接收到这个包时，也进入ESTABLISHED状态，TCP握手结束 为什么TCP是三次握手而不是两次握手两次握手的过程： A发送同步信号SYN+A‘s Initial sequence number B发送同步信号SYN+B’s Initial sequence number + B’s sequence 这里有一个问题，A与B就A的初始序号达成了一致，但是B无法知道A是否已经接收到自己的同步信号，如果这个同步信号丢失了，A和B就B的初始序列号将无法达成一致。 四次挥手 第一次挥手(FIN=1,seq=X，ACK=1) 假如客户端想要关闭连接，客户端发送一个FIN标志位为1,序列号为X，ACK为1的包，表示自己已经没有数据可以发送了，但是仍然可以接收数据，发送完毕后，客户端进入FIN_WAIT_1状态 第二次挥手(ACk=1,ACKnum=X+1) 服务器端确认客户端的FIN报文段，发送一个确认包，表明自己接收到了客户端关闭连接的请求，但是还没有准备好关闭连接。发送完毕后，服务器端进入CLOSED_WAIT转态，客户端接收到这个确认包之后，进入 FIN_WAIT_2 状态，等待服务器端关闭连接。 第三次挥手(FIN=1,seq=Y) 服务器端准备好关闭连接时，向客户端发送结束连接请求，FIN 置为1。 发送完毕后，服务器端进入 LAST_ACK 状态，等待来自客户端的最后一个ACK。 第四次挥手(ACK=1,ACknum=y+1) 客户端接收到来自服务器端的关闭请求，发送一个确认包，并进入 TIME_WAIT状态，等待可能出现的要求重传的 ACK 包。 服务器端接收到这个确认包之后，关闭连接，进入 CLOSED 状态。 客户端等待了某个固定时间（两个最大段生命周期，2MSL，2 Maximum Segment Lifetime）之后，没有收到服务器端的 ACK ，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入 CLOSED 状态]]></content>
      <categories>
        <category>Computer Network</category>
      </categories>
      <tags>
        <tag>TCP/UDP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[死锁]]></title>
    <url>%2F2018%2F08%2F19%2F%E6%AD%BB%E9%94%81%2F</url>
    <content type="text"><![CDATA[何为死锁所谓死锁，是指多个进程在运行过程中因争夺资源而造成的一种僵局，当进程处于这种僵持状态时，若无外力作用，他们都将无法再向前推进。 产生死锁的原因 竞争资源。当系统中供多个进程共享的资源如打印机、共用队列等，其数目不足以满足各个进程的需要时，会引起各个进程对资源的竞争而产生死锁。 进程间的推进顺序非法。进程在运行过程中，请求和释放资源的顺序不当，同样会导致进程死锁。 产生死锁的必要条件死锁的发生必须具有以下四个必要条件 互斥条件 指进程对分配到的资源进行排他性使用，即在一段时间内某资源只有一个进程占用。如果此时还有其它进程请求该资源，则请求者只能等待，直到占有该资源的进程用毕释放。 请求和保持条件 指进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。 不剥夺条件 指进程已获得资源，在未使用完之前，不能被剥夺，只能在使用完时自己释放 环路等待条件 指在发生死锁时，必然存在一个进程—–资源环形链，即进程集合{P0,P1,P2,….,Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源,…,Pn正在等待已被P0占用的资源 处理死锁的基本方法 预防死锁。这是一种较简单和直观的事先预防的方法。该方法是通过设置某些限制条件，去破坏产生死锁的四个必要条件中的一个或几个条件，来预防发生死锁。 避免死锁：该方法同样是属于事先预防的策略，但它并不须事先采取各种限制措施去破坏产生死锁的四个必要条件，而是在资源的动态分配过程中，用某种方法去防止系统进入不安全状态，从而避免发生死锁。这种方法只需事先施加较弱的限制条件，便可获得较高的资源利用率及系统吞吐量，但在实现上有一定的难度。目前在较完善的系统中常用此方法来避免发生死锁 检测死锁：这种方法并不须事先采取任何限制性措施，也不必检查系统是否已经进入不安全区，而是允许系统在运行过程中发生死锁。但可通过系统所设置的检测机构，及时地检测出死锁的发生，并精确地确定与死锁有关的进程和资源； 然后，采取适当措施，从系统中将已发生的死锁清除掉 解除死锁：这是与检测死锁相配套的一种措施。当检测到系统中已发生死锁时，须将进程从死锁状态中解脱出来。常用的实施方法是撤消或挂起一些进程，以便回收一些资源，再将这些资源分配给已处于阻塞状态的进程，使之转为就绪状态，以继续运行。死锁的检测和解除措施有可能使系统获得较好的资源利用率和吞吐量，但在实现上难度也最大。]]></content>
      <categories>
        <category>Operating System</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[排序算法]]></title>
    <url>%2F2018%2F08%2F18%2F%E5%87%A0%E7%A7%8D%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[直接插入排序基本思想： 把n个待排的元素看成一个有序表和一个无序表。开始时有序表只包含一个元素，无序表中包含n-1个元素，排序的过程中每次从无序表中取出第一个元素，将它插入有序表的适当位置，使之成为新的有序表，重复n-1次即可 123456789101112131415def insertSort(lists): """插入排序""" size = len(lists) for i in range(1, size): for j in range(i, 0, -1): if lists[j] &lt; lists[j - 1]: lists[j], lists[j - 1] = lists[j - 1], lists[j] else: breakif __name__ == "__main__": lists = [54, 26, 74, 12, 3, 6, 85] insertSort(lists) print(lists) 直接选择排序基本思想： 选择排序（Selection Sort）是一种简单直观的排序算法。它的工作原理如下，首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 123456789101112131415def selectionSort(lists): size = len(lists) for i in range(0, size - 1): minIndex = i for j in range(i + 1, size): if lists[minIndex] &gt; lists[j]: minIndex = j if i != minIndex: lists[minIndex], lists[i] = lists[i], lists[minIndex]if __name__ == "__main__": lists = [54, 26, 74, 12, 3, 6, 85] selectionSort(lists) print(lists) 快速排序基本思想： 快速排序由C. A. R. Hoare在1962年提出。它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快&gt;速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。 算法步骤 从数列中挑出一个元素，称为”基准”（pivot）， 重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（相同的数可以到任何一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。 递归地（recursively）把小于基准值元素的子数列和大于基准值元素的子数列排序。 代码实现： 1234567891011121314151617181920212223def quick_sort(lists,left,right): #快速排序 if left &gt;= right: return lists key = lists[left] low = left high = right while left &lt; right: while left &lt; right and lists[right] &gt;= key: right -= 1 lists[left] = lists[right] while left &lt; right and lists[left] &lt;= key: left += 1 lists[right] = lists[left] lists[right] = key quick_sort(lists,low,left-1) quick_sort(lists,left+1,high) return lists if __name__ == '__main__': li = [12,0,25,8,369,156,24,36,48] a = quick_sort(li,0,len(li)-1) print(a) 归并排序基本思想： 归并排序是一种递归算法，它持续地将一个列表分成两半。如果列表是空的或者 只有一个元素，那么根据定义，它就被排序好了(最基本的情况)。如果列表里的元素超过一个，我们就把列表拆分，然后分别对两个部分调用递归排序。一旦这两个部分被排序好了，然后就可以对这两部分数列进行归并了。归并是这样一个过程:把两个排序好了的列表结合在一起组合成一个单一的有序的新列表。有自顶向下（递归法）和自底向上的两种实现方法。 代码实现： 1234567891011121314151617181920212223242526272829def mergesort(seq): """归并排序""" if len(seq) &lt;= 1: return seq mid = len(seq)//2 left = mergesort(seq[:mid]) right = mergesort(seq[mid:]) return merge(left,right)def merge(left,right): """合并两个已经排序好的列表，产生一个新的已排序好的列表""" result = [] i = 0 j = 0 while i &lt; len(left) and j &lt; len(right): if left[i] &lt;= right[j]: result.append(left[i]) i += 1 else: result.append(right[j]) j += 1 result += left[i:] result += right[j:] return resultseq = [5,3,0,6,1,4]print("排序前：",seq)result = mergesort(seq)print("排序后：",result) 希尔排序算法思想： 希尔排序有时又叫做“缩小间隔排序”，它以插入排序为基础，将原来要排序的列表划分为一些子列表，再对每一个子列表执行插入排序，从而实现对插入排序性能的改进。划分子列的特定方法是希尔排序的关键。我们并不是将原始列表分成含有连续元素的子列，而是确定一个划分列表的增量“i”，这个i更准确地说，是划分的间隔。然后把每间隔为i的所有元素选出来组成子列表，然后对每个子序列进行插入排序，最后当i=1时，对整体进行一次直接插入排序 12345678910111213141516171819def shell_sort(lists): # 希尔排序 count = len(lists) step = 2 group = count / step while group &gt; 0: for i in range(0, group): j = i + group while j &lt; count: k = j - group key = lists[j] while k &gt;= 0: if lists[k] &gt; key: lists[k + group] = lists[k] lists[k] = key k -= group j += group group /= step return lists 冒泡排序算法原理: 冒泡排序要对一个列表多次重复遍历。它要比较相邻的两项，并且交换顺序排错的项。每对 列表实行一次遍历，就有一个最大项排在了正确的位置。大体上讲，列表的每一个数据项都会在 其相应的位置“冒泡”。如果列表有n项，第一次遍历就要比较n-1对数据。需要注意，一旦列 表中最大(按照规定的原则定义大小)的数据是所比较的数据对中的一个，它就会沿着列表一直 后移，直到这次遍历结束。 代码实现： 12345678def bubble_sort(lists): # 冒泡排序 count = len(lists) for i in range(0, count): for j in range(i + 1, count): if lists[i] &gt; lists[j]: lists[i], lists[j] = lists[j], lists[i] return lists 堆排序算法原理 堆的概念 堆：本质是一种数组对象，特别重要的一点性质：任意的叶子节点小于（或大于）它所有的父节点。对此，又分为大顶堆和小顶堆，大顶堆要求节点的元素都要大于其孩子，小顶堆要求节点元素都小于其左右孩子，两者对左右孩子的大小关系不做任何要求。 利用堆排序，就是基于大顶堆或者小顶堆的一种排序方法下面，我们通过大顶堆来实现。 基本思想 堆排序可以按照以下步骤来完成： 首先将序列构建称为大顶堆 构建大顶堆 1.取出当前大顶堆的根节点，将其与序列末尾元素进行交换（此时：序列末尾的元素为已排序的最大值；由于交换了元素，当前位于根节点的堆并不一定满足大顶堆的性质）； 2.对交换后的n-1个序列元素进行调整，使其满足大顶堆的性质； 重复2.3步骤，直至堆中只有1个元素为止 代码实现 1234567891011121314151617181920212223242526# 调整堆def adjust_heap(lists, i, size): lchild = 2 * i + 1 rchild = 2 * i + 2 max = i if i &lt; size // 2: if lchild &lt; size and lists[lchild] &gt; lists[max]: max = lchild if rchild &lt; size and lists[rchild] &gt; lists[max]: max = rchild if max != i: lists[max], lists[i] = lists[i], lists[max] adjust_heap(lists, max, size) #创建堆def build_heap(lists, size): for i in range(0, (size//2))[::-1]: adjust_heap(lists, i, size) # 堆排序def heap_sort(lists): size = len(lists) build_heap(lists, size) for i in range(0, size)[::-1]: lists[0], lists[i] = lists[i], lists[0] adjust_heap(lists, 0, i) 何为排序算法的稳定性稳定的排序算法会让原本有相等键值的记录维持相对次序。也就是如果一个排序算法时稳定的，当有两个相等键值的记录R和S，且再原本的列表中R出现在S之前，在排序过的列表中R也将会是在S之前。 当相等的元素是无法分辨的，比如像是整数，稳定性并不是一个问题。然而，假设以下的数对将要以他们的第一个数字来排序 (4,1) (3,1) (3,7) (5,6) 在这个状况下，有可能产生两种不同的结果，一个是让相等键值的记录维持相对的次序，而另外一个则没有： (3,1) (3,7) (4,1) (5,6) (维持次序) ·(3,7) (3,1) (4,1) (5,6) (次序改变) 不稳定的排序算法可能会在相等的键值中改变记录的相对次序，但是稳定排序算法从来不会如此。不稳定排序算法可以特别的实现为稳定。 适用场景 若n较小(n&lt;=50)时，科采用直接插入或直接选择排序 若文件的初始状态基本有序（指正序），则应选用直接插入、冒泡或者快速排序 若n较大，则应采用：快速排序、堆排序或归并排序。 性能比较 相关链接：https://mp.weixin.qq.com/s/VX9LwTK77RUPLBFHPS1Z1A 相关链接：https://mp.weixin.qq.com/s/aSrvCPf8jmrYtVChsV7-Wg]]></content>
      <categories>
        <category>Data Structures and Algorithms</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用Kenkins定时执行python脚本]]></title>
    <url>%2F2018%2F08%2F18%2F%E5%88%A9%E7%94%A8Kenkins%E5%AE%9A%E6%97%B6%E6%89%A7%E8%A1%8Cpython%E8%84%9A%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[新建任务 构建触发器，每两个小时执行一次，如图 构建 —-&gt; 执行shell 代表shell脚本在/var/lib/crm-sync/下的run.sh脚本 run.sh脚本的填写 以root用户运行jenkins中shell命令 #打开配置文件 vim /etc/sysconfig/jenkins #修改$JENKINS_USER,并去掉当前的注释 JENKINS_USER=&#39;root&#39; 给文件添加执行权限 chmod +x run.sh chmod + x crm.py]]></content>
      <categories>
        <category>Project</category>
      </categories>
      <tags>
        <tag>Jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jenkins的部署]]></title>
    <url>%2F2018%2F08%2F18%2Fjenkins%E7%9A%84%E9%83%A8%E7%BD%B2%2F</url>
    <content type="text"><![CDATA[部署环境 centos6.68 首先安装JAVA(要用java) 首先查看java版本 若java版本大于java8，则可以忽略 若java版本小于java8，则进行更新或者安装 如下例程为参考 获取jenkins安装源文件 wget -O /etc/yum.repos.d/jenkins.repo http://pkg.jenkins-ci.org/redhat/jenkins.repo 导入公钥 安装Jenkins 配置文件修改 日志信息查看 启动:http://ip:8787 配置防火墙，放行8787端口 更新防火墙 $ service iptables restart 浏览器访问Jenkins主页 接着会提示安装插件，可以有选择的进行安装，进行Jenkins后也可以进行插件的安装 插件安装完毕完，进入主页 卸载 卸载软件：rpm -e jenkins 删除遗留文件：find / -iname jenkins|xargs -n 1000 rm -rf 重启: service jenkins restart 查看运行状态: service jenkins status 查看jenkins的启动日志: cat /var/log/jenkins/jenkins.log]]></content>
      <categories>
        <category>Project</category>
      </categories>
      <tags>
        <tag>Jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python的对象引用、可变性]]></title>
    <url>%2F2018%2F08%2F18%2FPython%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BC%95%E7%94%A8%E5%92%8C%E5%8F%AF%E5%8F%98%E6%80%A7%2F</url>
    <content type="text"><![CDATA[变量变量是标注，而不是盒子。如 12345&gt;&gt;&gt; a = [1,2,3]&gt;&gt;&gt; b = a&gt;&gt;&gt; a.append(4)&gt;&gt;&gt; b[1,2,3,4] 对象在赋值之前就存在了，所以应该把对象[1,2,3]看做一个容器，而变量a与b就是贴在上面的便利贴。 每个变量都有标识，类型和值。对象一旦创建，它的标识绝对不会变：可以把标识理解为对象在内存中的地址。is 运算符比较两个对象的标识；id()函数返回对象的标识。 is 和 ====运算符比较两个对象的值(对象中保存的数据),而is比较的是对象的标识。如 123456789101112&gt;&gt;&gt;a = [1,2,3]&gt;&gt;&gt;b =a&gt;&gt;&gt;a is bTrue&gt;&gt;&gt;a == bTrue&gt;&gt;&gt;d = [1,2,3,4,5]&gt;&gt;&gt;e = [1,2,3,4,5]&gt;&gt;&gt;d == eTrue&gt;&gt;&gt; d is eFalse 元组的相对不可变性元组与多数Python集合（列表、字典、集等等）一样，保存的是对象的引用。如果引用的元素是可变的，即使元素本身不可变，元素依然可变。也就是说，元组的不可变性是指tuple数据结构的物理内容(即保存的引用)不可变，与与引用的对象无关。 12345678910111213&gt;&gt;&gt;t1 = (1,2,[30,40])&gt;&gt;&gt;t2 = (1,2,[30,40])&gt;&gt;&gt;t1 == t2True&gt;&gt;&gt;id(t1[-1])4302515784t1[-1].append(99)&gt;&gt;&gt;t1(1,2,[30,40,99])&gt;&gt;&gt;id(t1[-1])4302515784&gt;&gt;&gt;t1 == t2False t1不可变，但是t1[-1]可变 t1[-1]的标识没变，只是值变了 浅复制复制列表最简单的方式就是使用内置的类型构造方法。例如 12345678&gt;&gt;&gt;l1 = [3,[55,44],(7,8,9)]&gt;&gt;&gt;l2 = list(l1)&gt;&gt;&gt;l2[3,[55,44],[7,8,9]]&gt;&gt;&gt;l1 == l2True&gt;&gt;&gt;l1 is l2False list(l1)创建l1的副本 副本与源列表相等 但是二者代表不同的对象 对于列表和其它可变序列来说，还能使用简洁的l2 = l1[:]语句创建副本 然而，构造方法或[:]做的是浅复制(即复制了最外层容器，副本中的元素是源容器中元素的引用)。如果所有的元素都是不可变的，那么没有这个问题，还能节省内存，但是，如果有可变的元素，可能产生意想不到的问题。 为任意对象做深复制和浅复制浅复制没有什么问题，但有时我们需要做的是深复制(即副本不共用内部对象的引用)。copy模块提供的deepcopy和copy函数能够为任意对象做深复制和浅复制。 123import copyl1 = [3,[55,44],(7,8,9)]l2 = copy.deepycopy(l1) 1234import copyl1 = [3,[55,44],(7,8,9)]l2 = copy.deepycopy(l1)l1.pop(2)]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Session and Cookies]]></title>
    <url>%2F2018%2F08%2F15%2FsessionAndCookies%2F</url>
    <content type="text"><![CDATA[会话什么时会话绘画可以简单理解为：用户打开一个浏览器，点击多个超链接，访问服务器多个web资源，然后关闭浏览器，整个过程叫做会话 会话过程中要解决的一些问题？ 每个用户在使用浏览器与服务器进行会话的过程中，不可避免各自灰产生一些数据，程序要想办法为每个用户保存这些数据 列如：用户点击链接通过一个servlet购买了一个商品，程序应该想办法保存用户购买的商品，以便于用户点击结账servlet时，结账servlet可以得到用户购买的商品为用户结账。 保存会话数据的两种技术cookiecookie是客户端技术。程序把每个用户的数据以cookies的形式写给用户各自的浏览器。当用户使用浏览器再去访问服务器中的web资源时，就会带着各自的数据去。这样，web资源处理的就是用户各自的数据了。 HttpSessionSession是服务端技术。利用这个技术，服务器在运行时可以为每一个用户的浏览器创建一个其独享的HttpSession对象，由于session为用户浏览器独享，所以用户在访问服务器的web资源时，可以把各自的数据放在各自的session中，当用户再去访问服务器中的其它web资源时，其它web资源再从用户各自的session中取出数据为用户服务。]]></content>
      <categories>
        <category>Computer Network</category>
      </categories>
      <tags>
        <tag>cookies</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[栈和队列]]></title>
    <url>%2F2018%2F08%2F14%2Fstack%2F</url>
    <content type="text"><![CDATA[栈栈的压入，弹出序列输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的） 12345678910111213141516171819202122232425class Solutuon: def IsPopOrder(self,pushV,popV): length1 = len(pushV) length1 = len(popV) if length1 != legth2 or length1 == 0: return Flase p1_begin = 0 p2_begin = 0 stack = [] while True: number = pushV[p1_begin] stack.append(number) while stack and stack[-1] == popV[p2_begin]: p2_begin += 1 stack.pop() if p1_begin == length1 -1: if stack: return False else: return True p1_begin += 1 注: ​ pushV = [5,4,3,2,1] ​ popV = [4,5,3,2,1] 用两个栈实现队列用两个栈来实现一个队列，完成队列的Push和Pop操作。队列中的元素为int类型 思路 我们通过一个具体的例子分析往该队列插入和删除元素的过程。首先插入一个元素a，不妨先把它插入到stack1，此时stack1中的元素有{a}，stack2为空。再压入两个元素b和c，还是插入到stack1中，此时stack1的元素有{a,b,c}，其中c位于栈顶，而stack2仍然是空的。 这个时候我们试着从队列中删除一个元素。按照先入先出的规则，由于a比b、c先插入队列中，最先删除的元素应该是a。元素a存储在stack1中，但并不在栈顶，因此不能直接进行删除操作。注意stack2我们一直没有使用过，现在是让stack2发挥作用的时候了。如果我们把stack1中的元素逐个弹出压入stack2，元素在stack2中的顺序正好和原来在stack1中的顺序相反。因此经过3次弹出stack1和要入stack2操作之后，stack1为空，而stack2中的元素是{c,b,a}，这个时候就可以弹出stack2的栈顶a了。此时的stack1为空，而stack2的元素为{b,a}，其中b在栈顶。 因此我们的思路是：当stack2中不为空时，在stack2中的栈顶元素是最先进入队列的元素，可以弹出。如果stack2为空时，我们把stack1中的元素逐个弹出并压入stack2。由于先进入队列的元素被压倒stack1的栈底，经过弹出和压入之后就处于stack2的栈顶，有可以直接弹出。如果有新元素d插入，我们直接把它压入stack1即可。 1234567891011class Soluton: def __init__(self): self.stack1 = [] self.stack2 = [] def push(self,node): self.stack1.append(node) def pop(self): if len(self.stack2) == 0: while self.stack1: self.stack2.append(self.stack1.pop()) return self.stack2.pop() 用两个队列实现栈进栈：元素入队A 出栈：判断如果队A只有一个元素，则直接出队。否则，把队A中的元素出队并入队B，直到队A中只有一个元素，再直接出队。 分析：直接用python的list实现栈，以list尾为栈首，则出栈和进栈的复杂度都为O(1).而用两个队列实现栈，因为进栈要用insert,因此复杂度为O(n);出栈复杂度为O(n^2),因为需要连续insert 12345678910111213class Stack: def __init__(self): self.queueA=[] self.queueB=[] def push(self, node): self.queueA.insert(0,node) def pop(self): if self.queueA==[]: return None while len(self.queueA)!=1: self.queueB.insert(0,self.queueA.pop()) self.queueA,self.queueB=self.queueB,self.queueA return self.queueB.pop()]]></content>
      <categories>
        <category>Data Structures and Algorithms</category>
      </categories>
      <tags>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP协议]]></title>
    <url>%2F2018%2F08%2F14%2FHTTP%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[HTTP的作用HTTP协议规定了客户端与服务器之间交互的消息内容和步骤。 HTTP的消息结构HTTP是基于客户端/服务端的架构模型，通过一个可靠的链接来交换信息，是一个无状态的请求/响应协议。 客户端请求消息客户端发送一个HTTP请求到服务器的请求消息包括以下格式:请求格式(request line)、请求头部、空行和请求数据四个部分组成，如图: 下面给了请求报文的一般格式。 服务器响应消息HTTP响应也由四个部分组成，分别是:状态行、消息报头、空行和响应正文。 实例客户端请求 1234GET /hello.txt HTTP/1.1User-Agent: curl/7.16.3 libcurl/7.16.3 OpenSSL/0.9.71 zlib/1.2.3Host:www.example.comAccept-Lanuage: en,mi 服务端响应 123456789HTTP/1.1 200 OKData：Mon,27 Jul 2009 12:28:53 GMTServer:ApacheLast_Modified:Wed,22 Jul 2009 19:15:56 GMTETag: "34aa387-d-1568eb00"Accept-Ranges: bytesContent-Length: 51Vary: Accept-EncodingContent-Type:text/plain 输出结果： 1Hello World! My payload includes a trailing CRLF. HTTP的请求HTTP请求方法HTTP1.0 定义了三种请求方法: GET，POST ，HEAD HTTP1.1 新增了五种请求方法: OPTIONS， PUT ，DELETE，TRACE和CONNECT方法 GET和POST的区别 GET提交的数据大小有限制，而POST方法提交的数据么有限制 GET方式提交数据，会带来安全问题，比如一个登录页面，通过GET方式提交数据时，用户名和密码将出现在URL上，如果页面可以被缓存或者其他人可以访问这台机器，就可以从历史记录获得该用户的账号和密码. GET提交的数据会放在URL之后，以?分割URL和传输数据，参数之间以&amp;相连，如EditPosts.aspx?name=test1&amp;id=123456. POST方法是把提交的数据放在HTTP包的Body中. GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值。 HTTP请求头请求头的规格中定义了很多项目，如日期、客户端支持的数据类型、语言、压缩格式、客户端和服务器的软件名称和排版、数据有效期和最后更新时间等。 DATA：表示请求和响应生成的日期 Accept: 告诉服务器，客户机支持的数据类型 Accept-Charset: 告诉服务器，客户机采用的编码 Accept-Encoding：告诉服务器，客户机支持的压缩格式 Accept-Language：客户机的语言环境 Host：客户机通过这个头告诉服务器想访问的主机 Connection：设置发送响应之后TCP连接是否继续保持的通信选项 User-Agent：客户端软件的名称和版本号等相关信息 HTTP响应头消息 应答头 说明 Allow 服务器支持哪些请求方法(如GET,POST等) Content-Encoding 文档的编码（Encode）方法。只有在解码之后才可以得到Content-Type头指定的内容类型。利用gzip压缩文档能够显著地减少HTML文档的下载时间。 Content-Length 表示内容长度。只有当浏览器使用持久HTTP连接时才需要这个数据。如果你想要利用持久连接的优势，可以把输出文档写入 ByteArrayOutputStream，完成后查看其大小，然后把该值放入Content-Length头，最后通过byteArrayStream.writeTo(response.getOutputStream()发送内容。 Content-Type 表示后面的文档属于什么MIME类型。Servlet默认为text/plain，但通常需要显式地指定为text/html。由于经常要设置Content-Type，因此HttpServletResponse提供了一个专用的方法setContentType。 Set-Cookie 设置和页面关联的Cookie。Servlet不应使用response.setHeader(“Set-Cookie”, …)，而是应使用HttpServletResponse提供的专用方法addCookie。参见下文有关Cookie设置的讨论。 HTTP 状态码当浏览者访问一个网页时，浏览者的浏览器会向网页所在服务器发出请求。当浏览器接收并显示网页前，此网页所在的服务器会返回一个包含HTTP状态码的信息头（server header）用以响应浏览器的请求 。 HTTP状态码的英文为HTTP Status Code。 下面是常见的HTTP状态码: 200-请求成功 301-资源被永久移转到其它URL 404-请求的资源(网页等)不存在 500-内部服务器错误 HTTP状态码分类 分类 分类描述 1** 信息，服务器收到请求，需要请求者继续执行操作 2** 成功，操作被成功接收并处理 3** 重定向，需要进一步的操作以完成请求 4** 客户端错误，请求包含语法错误或无法完成请求 5** 服务器错误，服务器在处理请求的过程中发生了错误 HTTP content-type Content-Type，内容类型，一般是指网页中存在的Content-Type，用于定义网络文件的类型和网页的编码，决定浏览器将以什么形式、什么编码读取这个文件，这就是经常看到一些Asp网页点击的结果却是下载到的一个文件或一张图片的原因]]></content>
      <categories>
        <category>Computer Network</category>
      </categories>
      <tags>
        <tag>Http</tag>
      </tags>
  </entry>
</search>
